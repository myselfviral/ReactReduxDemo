'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = updateScale;

var _d3Shape = require('d3-shape');

function updateScale(props) {
  var type = props.type,
      id = props.id,
      materializedData = props.materializedData,
      cutoutPercentage = props.cutoutPercentage,
      width = props.width,
      height = props.height,
      dispatch = props.dispatch,
      outerPadding = props.outerPadding,
      cornerRadius = props.cornerRadius,
      arcPadding = props.arcPadding,
      seriesPadding = props.seriesPadding;
  // We need the data to proceed

  if (!materializedData) {
    return;
  }

  var midX = width / 2;
  var midY = height / 2;
  var radius = Math.max(Math.min(midX, midY) - outerPadding, 0);

  var outerRadius = radius;
  var innerRadius = radius * cutoutPercentage;
  var totalRadius = outerRadius - innerRadius;
  var seriesRadius = totalRadius / materializedData.length;
  var padRadius = outerRadius * arcPadding * 20;
  var seriesPaddingRadius = totalRadius * seriesPadding / 2.5;
  var padAngle = 0.01;

  var data = materializedData.map(function (series) {
    var seriesInnerRadius = innerRadius + seriesRadius * series.index;
    var seriesOuterRadius = seriesRadius + seriesInnerRadius;

    var pie = (0, _d3Shape.pie)().sort(null).padAngle(padAngle).value(function (d) {
      return d.secondary;
    });

    var pieData = pie(series.datums);

    return pieData.map(function (d) {
      var arcData = {
        startAngle: d.startAngle,
        endAngle: d.endAngle,
        padAngle: d.padAngle,
        padRadius: padRadius,
        innerRadius: seriesInnerRadius + seriesPaddingRadius,
        outerRadius: seriesOuterRadius,
        cornerRadius: cornerRadius,
        seriesPaddingRadius: seriesPaddingRadius
        // Calculate the arc for the centroid
      };var arc = (0, _d3Shape.arc)().startAngle(arcData.startAngle).endAngle(arcData.endAngle).padAngle(arcData.padAngle).padRadius(arcData.padRadius).innerRadius(arcData.innerRadius).outerRadius(arcData.outerRadius).cornerRadius(arcData.cornerRadius);

      var centroid = arc.centroid();

      return {
        arcData: arcData,
        arc: arc,
        x: centroid[0] + midX,
        y: centroid[1] + midY
      };
    });
  });

  var primaryScale = function primaryScale(d) {
    return data[d.seriesIndex] ? data[d.seriesIndex][d.index] ? data[d.seriesIndex][d.index] : 0 : 0;
  };
  var secondaryScale = function secondaryScale() {};

  primaryScale.range = function () {
    return [0, width];
  };
  secondaryScale.range = function () {
    return [height, 0];
  };

  var primaryAxis = {
    id: id,
    scale: primaryScale,
    cutoutPercentage: cutoutPercentage,
    type: type,
    primary: true,
    format: function format(d) {
      return d;
    },
    width: width,
    height: height,
    radius: radius,
    cornerRadius: cornerRadius,
    arcPadding: arcPadding,
    seriesPadding: seriesPadding,
    outerRadius: outerRadius,
    innerRadius: innerRadius,
    totalRadius: totalRadius,
    seriesRadius: seriesRadius,
    padRadius: padRadius,
    seriesPaddingRadius: seriesPaddingRadius,
    padAngle: padAngle
  };

  var secondaryAxis = {
    id: id,
    scale: secondaryScale,
    format: function format(d) {
      return d;
    },
    type: type
  };

  dispatch(function (state) {
    return _extends({}, state, {
      axes: {
        pie_primary: primaryAxis,
        pie_secondary: secondaryAxis
      }
    });
  });
}