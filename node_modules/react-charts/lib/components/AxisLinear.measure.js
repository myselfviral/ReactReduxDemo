'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = measure;

var _AxisLinear = require('./AxisLinear');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var fontSize = 10;

var getPixel = function getPixel(d) {
  return d;
};
var radiansToDegrees = function radiansToDegrees(r) {
  return r * (180 / Math.PI);
};

function measure() {
  // Measure finds the amount of overflow this axis produces and
  // updates the margins to ensure that the axis is visibility
  // Unfortunately, this currently happens after a render, but potentially
  // could happen pre-render if we could reliably predict the size of the
  // labels before they render. Considering that ticks could be anything,
  // even a react component, this could get very tough.
  var _props = this.props,
      axis = _props.axis,
      tickSizeInner = _props.tickSizeInner,
      tickSizeOuter = _props.tickSizeOuter,
      tickPadding = _props.tickPadding,
      maxLabelRotation = _props.maxLabelRotation,
      position = _props.position,
      dispatch = _props.dispatch,
      id = _props.id;
  var rotation = this.state.rotation;
  var visibleLabelStep = this.visibleLabelStep;

  var resolvedRotation = rotation;

  if (!this.el) {
    // If the entire axis is hidden, then we need to remove the axis dimensions
    dispatch(function (state) {
      var newAxes = state.axisDimensions[position] || {};
      delete newAxes[id];
      return _extends({}, state, {
        axisDimensions: _extends({}, state.axisDimensions, _defineProperty({}, position, newAxes))
      });
    });
    return;
  }

  var isHorizontal = position === _AxisLinear.positionTop || position === _AxisLinear.positionBottom;
  var labelDims = Array.apply(undefined, _toConsumableArray(this.el.querySelectorAll('.tick text'))).map(function (el) {
    return _extends({}, el.getBoundingClientRect().toJSON());
  });

  var smallestTickGap = 100000;
  // This is just a ridiculously large tick spacing that would never happen (hopefully)
  // If the axis is horizontal, we need to determine any necessary rotation and tick skipping
  if (isHorizontal) {
    var tickDims = Array.apply(undefined, _toConsumableArray(this.el.querySelectorAll('.tick'))).map(function (el) {
      return el.getBoundingClientRect();
    });
    // Determine the smallest gap in ticks on the axis
    tickDims.reduce(function (prev, current) {
      if (prev) {
        var gap = current.left - prev.left;
        smallestTickGap = gap < smallestTickGap ? gap : smallestTickGap;
      }
      return current;
    }, false);

    // Determine the largest label on the axis
    var largestLabel = labelDims.reduce(function (prev, current) {
      current._overflow = current.width - smallestTickGap;
      if (current._overflow > 0 && current._overflow > prev._overflow) {
        return current;
      }
      return prev;
    }, _extends({}, labelDims[0], { _overflow: 0 }));

    // Determine axis rotation before we measure
    var newRotation = Math.min(Math.max(Math.abs(radiansToDegrees(Math.acos(smallestTickGap / (largestLabel.width + fontSize)))), 0), maxLabelRotation);

    newRotation = Number.isNaN(newRotation) ? 0 : Math.round(newRotation);
    resolvedRotation = newRotation;
    if (Math.abs(rotation - newRotation) > 10) {
      this.setState({
        rotation: axis.position === 'top' ? -newRotation : newRotation
      });
    }
  }

  var newVisibleLabelStep = Math.ceil(fontSize / smallestTickGap);

  if (visibleLabelStep !== newVisibleLabelStep) {
    this.visibleLabelStep = newVisibleLabelStep;
  }

  if (!labelDims.length || labelDims.length !== this.ticks.length) {
    return false;
  }

  var width = 0;
  var height = 0;
  var top = 0;
  var bottom = 0;
  var left = 0;
  var right = 0;

  if (isHorizontal) {
    // Add width overflow from the first and last ticks
    var leftWidth = getPixel(labelDims[0].width);
    var rightWidth = getPixel(labelDims[labelDims.length - 1].width);
    if (resolvedRotation) {
      right = Math.ceil(fontSize / 2);
      left = Math.abs(Math.ceil(Math.cos(resolvedRotation) * leftWidth)) - axis.barSize / 2;
    } else {
      left = Math.ceil(leftWidth / 2);
      right = Math.ceil(rightWidth / 2);
    }
    height = Math.max(tickSizeInner, tickSizeOuter) + // Add tick size
    tickPadding + // Add tick padding
    // Add the height of the largest label
    Math.max.apply(Math, _toConsumableArray(labelDims.map(function (d) {
      return Math.ceil(getPixel(d.height));
    })));
  } else {
    // Add height overflow from the first and last ticks
    top = Math.ceil(getPixel(labelDims[0].height) / 2);
    bottom = Math.ceil(getPixel(labelDims[labelDims.length - 1].height) / 2);
    width = Math.max(tickSizeInner, tickSizeOuter) + // Add tick size
    tickPadding + // Add tick padding
    // Add the width of the largest label
    Math.max.apply(Math, _toConsumableArray(labelDims.map(function (d) {
      return Math.ceil(getPixel(d.width));
    })));
  }

  var newDimensions = {
    width: width,
    height: height,
    top: top,
    bottom: bottom,
    left: left,
    right: right
  };

  dispatch(function (state) {
    return _extends({}, state, {
      axisDimensions: _extends({}, state.axisDimensions, _defineProperty({}, position, _extends({}, state.axisDimensions[position] || {}, _defineProperty({}, id, newDimensions))))
    });
  });

  return true;
}