'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _raf = require('raf');

var _raf2 = _interopRequireDefault(_raf);

var _ReactMove = require('./ReactMove');

var _Context = require('../utils/Context');

var _Utils = require('../utils/Utils');

var _Utils2 = _interopRequireDefault(_Utils);

var _Selectors = require('../utils/Selectors');

var _Selectors2 = _interopRequireDefault(_Selectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//


//

var triangleSize = 7;
var showCount = 10;

var getBackgroundColor = function getBackgroundColor(dark) {
  return dark ? 'rgba(255,255,255,.9)' : 'rgba(0, 26, 39, 0.9)';
};

var Tooltip = function (_React$PureComponent) {
  _inherits(Tooltip, _React$PureComponent);

  function Tooltip() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Tooltip);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call.apply(_ref, [this].concat(args))), _this), _this.updateTooltip = function (force) {
      var _this$props = _this.props,
          focus = _this$props.focus,
          align = _this$props.align,
          padding = _this$props.padding,
          tooltipArrowPadding = _this$props.tooltipArrowPadding,
          onChange = _this$props.onChange,
          hovered = _this$props.hovered,
          primaryAxes = _this$props.primaryAxes,
          secondaryAxes = _this$props.secondaryAxes,
          gridX = _this$props.gridX,
          gridY = _this$props.gridY,
          gridWidth = _this$props.gridWidth,
          gridHeight = _this$props.gridHeight,
          width = _this$props.width,
          height = _this$props.height,
          pointer = _this$props.pointer,
          dark = _this$props.dark;
      var arrowPosition = _this.props.arrowPosition;
      var alignPriority = _this.props.alignPriority;


      if (!primaryAxes.length || !secondaryAxes.length) {
        return null;
      }

      var hoveredDatums = hovered.datums && hovered.datums.length ? hovered.datums : [];

      // Get the closest focus datum out of the hoveredDatums
      var focusDatum = _Utils2.default.getClosestPoint(pointer, hoveredDatums);
      var active = hovered.active;

      if (_this.focusDatum === focusDatum && _this.active === active && !force) {
        return;
      }

      _this.focusDatum = focusDatum;
      _this.lastActive = _this.active;
      _this.active = active;

      // If there is a focusDatum, default the focus to its x and y
      if (_this.focusDatum) {
        _this.focus = _this.focusDatum.focus;
      }

      if (typeof focus === 'function') {
        // Support functional override for focus
        if (pointer) {
          _this.focus = focus({
            hoveredDatums: hoveredDatums,
            pointer: pointer,
            focusDatum: _this.focusDatum
          });
        }
      } else if (focus === 'pointer') {
        // Support pointer-bound focus
        _this.focus = pointer;
      } else if (focus === 'closest') {
        // Do nothing, this is already calculated
      } else if (hoveredDatums && hoveredDatums.length) {
        // Support manual definition of focus point using relative multiFocus strategy
        var multiFocus = _Utils2.default.isArray(focus) ? [].concat(_toConsumableArray(focus)) : [focus];
        _this.focus = _Utils2.default.getMultiFocus({
          focus: multiFocus,
          points: hoveredDatums,
          gridX: gridX,
          gridY: gridY,
          gridWidth: gridWidth,
          gridHeight: gridHeight,
          width: width,
          height: height
        });
      }

      if (!_this.focus) {
        return null;
      }

      var _this$focus = _this.focus,
          x = _this$focus.x,
          y = _this$focus.y,
          _this$focus$horizonta = _this$focus.horizontalPadding,
          horizontalPadding = _this$focus$horizonta === undefined ? 0 : _this$focus$horizonta,
          _this$focus$verticalP = _this$focus.verticalPadding,
          verticalPadding = _this$focus$verticalP === undefined ? 0 : _this$focus$verticalP;


      var alignX = '0%';
      var alignY = '-50%';
      var triangleStyles = {};
      var resolvedAlign = align || 'auto';

      var backgroundColor = getBackgroundColor(dark);

      if (align === 'auto') {
        if (_this.el) {
          var gridDims = _this.el.getBoundingClientRect();
          var tooltipDims = _this.tooltipEl.getBoundingClientRect();
          var container = _this.el;
          var space = {
            left: Infinity,
            top: Infinity,
            right: Infinity,
            bottom: Infinity
          };

          while (container !== document.body) {
            container = container.parentElement;

            var _window$getComputedSt = window.getComputedStyle(container),
                overflowX = _window$getComputedSt.overflowX,
                overflowY = _window$getComputedSt.overflowY;

            if (container === document.body || [overflowX, overflowY].find(function (d) {
              return ['auto', 'hidden'].includes(d);
            })) {
              var containerDims = container.getBoundingClientRect();
              var left = gridDims.left - containerDims.left + _this.focus.x;
              var top = gridDims.top - containerDims.top + _this.focus.y;
              var right = containerDims.width - left;
              var bottom = containerDims.height - top;

              space.left = Math.min(space.left, left);
              space.top = Math.min(space.top, top);
              space.right = Math.min(space.right, right);
              space.bottom = Math.min(space.bottom, bottom);
            }
          }

          resolvedAlign = null;

          alignPriority.forEach(function (priority) {
            if (resolvedAlign) {
              return;
            }
            if (priority === 'left') {
              if (space.left - tooltipArrowPadding - padding - horizontalPadding > tooltipDims.width && space.top > tooltipDims.height / 2 && space.bottom > tooltipDims.height / 2) {
                resolvedAlign = priority;
              }
            } else if (priority === 'right') {
              if (space.right - tooltipArrowPadding - padding - horizontalPadding > tooltipDims.width && space.top > tooltipDims.height / 2 && space.bottom > tooltipDims.height / 2) {
                resolvedAlign = priority;
              }
            } else if (priority === 'top') {
              if (space.top - tooltipArrowPadding - padding - verticalPadding > tooltipDims.height && space.left > tooltipDims.width / 2 && space.right > tooltipDims.width / 2) {
                resolvedAlign = priority;
              }
            } else if (priority === 'bottom') {
              if (space.bottom - tooltipArrowPadding - padding - verticalPadding > tooltipDims.height && space.left > tooltipDims.width / 2 && space.right > tooltipDims.width / 2) {
                resolvedAlign = priority;
              }
            } else if (priority === 'topLeft') {
              if (space.top - tooltipArrowPadding > tooltipDims.height && space.left - tooltipArrowPadding > tooltipDims.width) {
                resolvedAlign = priority;
              }
            } else if (priority === 'topRight') {
              if (space.top - tooltipArrowPadding > tooltipDims.height && space.right - tooltipArrowPadding > tooltipDims.width) {
                resolvedAlign = priority;
              }
            } else if (priority === 'bottomLeft') {
              if (space.bottom - tooltipArrowPadding > tooltipDims.height && space.left - tooltipArrowPadding > tooltipDims.width) {
                resolvedAlign = priority;
              }
            } else if (priority === 'bottomRight') {
              if (space.bottom - tooltipArrowPadding > tooltipDims.height && space.right - tooltipArrowPadding > tooltipDims.width) {
                resolvedAlign = priority;
              }
            }
          });
        }
      }

      if (resolvedAlign === 'top') {
        alignX = '-50%';
        alignY = '-100%';
      } else if (resolvedAlign === 'topRight') {
        alignX = '0%';
        alignY = '-100%';
      } else if (resolvedAlign === 'right') {
        alignX = '0%';
        alignY = '-50%';
      } else if (resolvedAlign === 'bottomRight') {
        alignX = '0%';
        alignY = '0%';
      } else if (resolvedAlign === 'bottom') {
        alignX = '-50%';
        alignY = '0%';
      } else if (resolvedAlign === 'bottomLeft') {
        alignX = '-100%';
        alignY = '0%';
      } else if (resolvedAlign === 'left') {
        alignX = '-100%';
        alignY = '-50%';
      } else if (resolvedAlign === 'topLeft') {
        alignX = '-100%';
        alignY = '-100%';
      }

      if (!arrowPosition) {
        if (resolvedAlign === 'left') {
          arrowPosition = 'right';
        } else if (resolvedAlign === 'right') {
          arrowPosition = 'left';
        } else if (resolvedAlign === 'top') {
          arrowPosition = 'bottom';
        } else if (resolvedAlign === 'bottom') {
          arrowPosition = 'top';
        }
      }

      if (arrowPosition === 'bottom') {
        triangleStyles = {
          top: '100%',
          left: '50%',
          transform: 'translate3d(-50%, 0%, 0)',
          borderLeft: triangleSize * 0.8 + 'px solid transparent',
          borderRight: triangleSize * 0.8 + 'px solid transparent',
          borderTop: triangleSize + 'px solid ' + backgroundColor
        };
      } else if (arrowPosition === 'top') {
        triangleStyles = {
          top: '0%',
          left: '50%',
          transform: 'translate3d(-50%, -100%, 0)',
          borderLeft: triangleSize * 0.8 + 'px solid transparent',
          borderRight: triangleSize * 0.8 + 'px solid transparent',
          borderBottom: triangleSize + 'px solid ' + backgroundColor
        };
      } else if (arrowPosition === 'right') {
        triangleStyles = {
          top: '50%',
          left: '100%',
          transform: 'translate3d(0%, -50%, 0)',
          borderTop: triangleSize * 0.8 + 'px solid transparent',
          borderBottom: triangleSize * 0.8 + 'px solid transparent',
          borderLeft: triangleSize + 'px solid ' + backgroundColor
        };
      } else if (arrowPosition === 'left') {
        triangleStyles = {
          top: '50%',
          left: '0%',
          transform: 'translate3d(-100%, -50%, 0)',
          borderTop: triangleSize * 0.8 + 'px solid transparent',
          borderBottom: triangleSize * 0.8 + 'px solid transparent',
          borderRight: triangleSize + 'px solid ' + backgroundColor
        };
      } else {
        triangleStyles = {
          opacity: 0
        };
      }

      var opacity = hovered.active ? 1 : 0;

      var primaryAxis = _Utils2.default.getAxisByAxisID(primaryAxes, _this.focusDatum ? _this.focusDatum.series.primaryAxisID : null);
      var secondaryAxis = _Utils2.default.getAxisByAxisID(secondaryAxes, _this.focusDatum ? _this.focusDatum.series.secondaryAxisID : null);

      var tooltip = {
        x: x,
        y: y,
        horizontalPadding: horizontalPadding,
        verticalPadding: verticalPadding,
        alignX: alignX,
        alignY: alignY,
        triangleStyles: triangleStyles,
        opacity: opacity,
        primaryAxis: primaryAxis,
        secondaryAxis: secondaryAxis,
        focusDatum: _this.focusDatum
      };

      onChange(tooltip);

      _this.props.dispatch(function (state) {
        return _extends({}, state, {
          tooltip: tooltip
        });
      });
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Tooltip, [{
    key: 'componentDidUpdate',
    value: function componentDidUpdate(oldProps) {
      if (oldProps.pointer !== this.props.pointer) {
        this.updateTooltip();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          _props$offset = _props.offset,
          left = _props$offset.left,
          top = _props$offset.top,
          gridX = _props.gridX,
          gridY = _props.gridY,
          gridWidth = _props.gridWidth,
          gridHeight = _props.gridHeight,
          tooltip = _props.tooltip,
          padding = _props.padding,
          primaryAxes = _props.primaryAxes,
          secondaryAxes = _props.secondaryAxes,
          tooltipArrowPadding = _props.tooltipArrowPadding,
          children = _props.children,
          render = _props.render,
          dark = _props.dark,
          Comp = _props.Component,
          rest = _objectWithoutProperties(_props, ['offset', 'gridX', 'gridY', 'gridWidth', 'gridHeight', 'tooltip', 'padding', 'primaryAxes', 'secondaryAxes', 'tooltipArrowPadding', 'children', 'render', 'dark', 'Component']);

      var x = tooltip.x,
          y = tooltip.y,
          horizontalPadding = tooltip.horizontalPadding,
          verticalPadding = tooltip.verticalPadding,
          alignX = tooltip.alignX,
          alignY = tooltip.alignY,
          triangleStyles = tooltip.triangleStyles,
          _tooltip$opacity = tooltip.opacity,
          opacity = _tooltip$opacity === undefined ? 0 : _tooltip$opacity,
          primaryAxis = tooltip.primaryAxis,
          secondaryAxis = tooltip.secondaryAxis;


      var resolvedHorizontalPadding = padding + horizontalPadding;
      var resolvedVerticalPadding = padding + verticalPadding;

      var start = {
        opacity: 0
      };

      var update = {
        opacity: opacity,
        left: left + gridX + 'px',
        top: top + gridY + 'px',
        width: gridWidth + 'px',
        height: gridHeight + 'px'
      };

      var renderedChildren = void 0;
      var renderProps = _extends({
        datum: this.focusDatum,
        getStyle: function getStyle(datum) {
          return datum.getStatusStyle(_Utils2.default.getStatus(datum, rest.hovered, rest.selected));
        },
        primaryAxes: primaryAxes,
        secondaryAxes: secondaryAxes,
        primaryAxis: primaryAxis,
        secondaryAxis: secondaryAxis
      }, rest);
      if (Comp) {
        renderedChildren = _react2.default.createElement(Comp, null, _extends({}, rest, renderProps));
      } else {
        renderedChildren = (render || children)(renderProps);
      }

      return _react2.default.createElement(
        _ReactMove.Animate,
        {
          show: !!opacity,
          start: start,
          enter: update,
          update: update,
          leave: update,
          className: 'tooltip-wrap',
          style: {
            pointerEvents: 'none',
            position: 'absolute'
          },
          innerRef: function innerRef(el) {
            _this2.el = el;
          }
        },
        _react2.default.createElement(
          'div',
          {
            style: {
              position: 'absolute',
              left: 0,
              top: 0,
              transform: 'translate3d(' + x + 'px, ' + y + 'px, 0px)',
              transition: 'all .2s ease-out'
            }
          },
          _react2.default.createElement(
            'div',
            {
              style: {
                transform: 'translate3d(' + alignX + ', ' + alignY + ', 0)',
                padding: tooltipArrowPadding + resolvedVerticalPadding + 'px ' + (tooltipArrowPadding + resolvedHorizontalPadding) + 'px',
                width: 'auto',
                transition: 'all .2s ease-out'
              }
            },
            _react2.default.createElement(
              'div',
              {
                ref: function ref(el) {
                  _this2.tooltipEl = el;
                  if (_this2.active && !_this2.lastActive) {
                    (0, _raf2.default)(function () {
                      return _this2.updateTooltip(true);
                    });
                  }
                },
                style: {
                  fontSize: '12px',
                  padding: '5px',
                  background: getBackgroundColor(dark),
                  color: dark ? 'black' : 'white',
                  borderRadius: '3px',
                  position: 'relative',
                  transition: 'all .2s ease-out'
                }
              },
              _react2.default.createElement('div', {
                style: _extends({
                  position: 'absolute',
                  width: 0,
                  height: 0
                }, triangleStyles, {
                  transition: 'all .2s ease-out'
                })
              }),
              renderedChildren
            )
          )
        )
      );
    }
  }]);

  return Tooltip;
}(_react2.default.PureComponent);

Tooltip.defaultProps = {
  focus: 'closest',
  align: 'auto',
  alignPriority: ['right', 'top', 'left', 'bottom', 'topRight', 'topLeft', 'bottomLeft', 'bottomRight'],
  children: defaultRenderer,
  padding: 1,
  tooltipArrowPadding: 7,
  onChange: function onChange() {}
};
Tooltip.isHtml = true;


function defaultRenderer(props) {
  var datum = props.datum,
      primaryAxis = props.primaryAxis,
      secondaryAxis = props.secondaryAxis,
      formatSecondary = props.formatSecondary,
      getStyle = props.getStyle,
      dark = props.dark;


  if (!datum) {
    return null;
  }

  var resolvedFormatSecondary = formatSecondary || function (val) {
    return Math.floor(val) < val ? secondaryAxis.format(Math.round(val * 100) / 100) : secondaryAxis.format(val);
  };

  var sortedGroupDatums = secondaryAxis && secondaryAxis.stacked ? [].concat(_toConsumableArray(datum.group)).reverse() : [].concat(_toConsumableArray(datum.group)).sort(function (a, b) {
    if (a.secondary < b.secondary) {
      return -1;
    } else if (a.secondary > b.secondary) {
      return 1;
    }
    return a.seriesIndex < b.seriesIndex ? 1 : -1;
  }).reverse();

  if (secondaryAxis.invert) {
    sortedGroupDatums.reverse();
  }

  var resolvedShowCount = showCount % 2 === 0 ? showCount : showCount + 1;
  var length = sortedGroupDatums.length;

  // Get the hovered series' index
  var activeIndex = sortedGroupDatums.findIndex(function (d) {
    return d === datum;
  });
  // Get the start by going back half of the showCount
  var start = activeIndex > -1 ? activeIndex - resolvedShowCount / 2 : 0;
  // Make sure it's at least 0
  start = Math.max(start, 0);
  // Use the start and add the showCount to get the end
  var end = activeIndex > -1 ? start + resolvedShowCount : length;
  // Don't let the end go passed the length
  end = Math.min(end, length);
  // Double check we aren't clipping the start
  start = Math.max(end - resolvedShowCount, 0);
  // Slice the datums by start and end
  var visibleSortedGroupDatums = sortedGroupDatums.slice(start, end);
  // Detect if we have previous items
  var hasPrevious = start > 0;
  // Or next items
  var hasNext = end < length;

  return _react2.default.createElement(
    'div',
    null,
    _react2.default.createElement(
      'div',
      {
        style: {
          marginBottom: '3px',
          textAlign: 'center'
        }
      },
      _react2.default.createElement(
        'strong',
        null,
        primaryAxis.format(datum.primary)
      )
    ),
    _react2.default.createElement(
      'table',
      {
        style: {
          whiteSpace: 'nowrap'
        }
      },
      _react2.default.createElement(
        'tbody',
        null,
        hasPrevious ? _react2.default.createElement(
          'tr',
          {
            style: {
              opacity: 0.8
            }
          },
          _react2.default.createElement('td', null),
          _react2.default.createElement(
            'td',
            null,
            '...'
          ),
          _react2.default.createElement('td', null)
        ) : null,
        visibleSortedGroupDatums.map(function (sortedDatum, i) {
          var active = sortedDatum === datum;
          return _react2.default.createElement(
            'tr',
            {
              key: i,
              style: {
                opacity: active ? 1 : 0.8
              }
            },
            _react2.default.createElement(
              'td',
              {
                style: {
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  marginRight: '5px'
                }
              },
              _react2.default.createElement(
                'svg',
                { width: '16', height: '16' },
                _react2.default.createElement('circle', {
                  cx: '8',
                  cy: '8',
                  style: _extends({}, getStyle(sortedDatum), {
                    r: 7,
                    stroke: dark ? 'black' : 'white',
                    strokeWidth: active ? 2 : 1
                  })
                })
              )
            ),
            _react2.default.createElement(
              'td',
              null,
              sortedDatum.seriesLabel,
              ': \xA0'
            ),
            _react2.default.createElement(
              'td',
              {
                style: {
                  textAlign: 'right'
                }
              },
              resolvedFormatSecondary(sortedDatum.secondary)
            )
          );
        }),
        hasNext ? _react2.default.createElement(
          'tr',
          {
            style: {
              opacity: 0.8
            }
          },
          _react2.default.createElement('td', null),
          _react2.default.createElement(
            'td',
            null,
            '...'
          ),
          _react2.default.createElement('td', null)
        ) : null,
        secondaryAxis && secondaryAxis.stacked && datum.group.length > 1 ? _react2.default.createElement(
          'tr',
          null,
          _react2.default.createElement(
            'td',
            {
              style: {
                paddingTop: '5px'
              }
            },
            _react2.default.createElement('div', {
              style: {
                width: '12px',
                height: '12px',
                backgroundColor: dark ? 'rgba(0, 26, 39, 0.3)' : 'rgba(255,255,255,.2)',
                borderRadius: '50px'
              }
            })
          ),
          _react2.default.createElement(
            'td',
            {
              style: {
                paddingTop: '5px'
              }
            },
            'Total: \xA0'
          ),
          _react2.default.createElement(
            'td',
            {
              style: {
                paddingTop: '5px'
              }
            },
            resolvedFormatSecondary([].concat(_toConsumableArray(datum.group)).reverse()[0].totalValue)
          )
        ) : null
      )
    )
  );
}

exports.default = (0, _Context.PointerConnect)(function (state) {
  return {
    pointer: state.pointer
  };
})((0, _Context.ChartConnect)(function () {
  var selectors = {
    primaryAxes: _Selectors2.default.primaryAxes(),
    secondaryAxes: _Selectors2.default.secondaryAxes(),
    gridX: _Selectors2.default.gridX(),
    gridY: _Selectors2.default.gridY(),
    gridWidth: _Selectors2.default.gridWidth(),
    gridHeight: _Selectors2.default.gridHeight(),
    offset: _Selectors2.default.offset()
  };
  return function (state) {
    return {
      primaryAxes: selectors.primaryAxes(state),
      secondaryAxes: selectors.secondaryAxes(state),
      gridX: selectors.gridX(state),
      gridY: selectors.gridY(state),
      gridWidth: selectors.gridWidth(state),
      gridHeight: selectors.gridHeight(state),
      width: state.width,
      height: state.height,
      hovered: state.hovered,
      tooltip: state.tooltip,
      offset: selectors.offset(state),
      dark: state.dark
    };
  };
})(Tooltip));