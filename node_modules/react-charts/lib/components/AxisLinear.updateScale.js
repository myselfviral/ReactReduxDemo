'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = updateScale;

var _d3Scale = require('d3-scale');

var _AxisLinear = require('./AxisLinear');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
//


var scales = {
  linear: _d3Scale.scaleLinear,
  log: _d3Scale.scaleLog,
  time: _d3Scale.scaleTime,
  utc: _d3Scale.scaleUtc,
  ordinal: _d3Scale.scaleBand
};

var detectVertical = function detectVertical(position) {
  return [_AxisLinear.positionLeft, _AxisLinear.positionRight].indexOf(position) > -1;
};
var detectRTL = function detectRTL(position) {
  return [_AxisLinear.positionTop, _AxisLinear.positionRight].indexOf(position) > -1;
};

function updateScale(props) {
  var _scale, _scale2;

  var id = props.id,
      type = props.type,
      position = props.position,
      invert = props.invert,
      primary = props.primary,
      stacked = props.stacked,
      innerPadding = props.innerPadding,
      outerPadding = props.outerPadding,
      tickArguments = props.tickArguments,
      tickValues = props.tickValues,
      tickFormat = props.tickFormat,
      tickPadding = props.tickPadding,
      tickSizeInner = props.tickSizeInner,
      base = props.base,
      defaultMin = props.min,
      defaultMax = props.max,
      hardMin = props.hardMin,
      hardMax = props.hardMax,
      primaryAxisID = props.primaryAxisID,
      materializedData = props.materializedData,
      width = props.width,
      height = props.height,
      primaryAxes = props.primaryAxes;

  // We need the data to proceed

  if (!materializedData) {
    return;
  }

  // If this axis is secondary, we need the primaryAxes to proceed
  if (!primary && !primaryAxes.length) {
    return;
  }

  // Detect some settings
  var valueKey = primary ? 'primary' : 'secondary';
  var groupKey = !primary && 'primary';
  var AxisIDKey = valueKey + 'AxisID';
  var vertical = detectVertical(position);
  var RTL = detectRTL(position); // Right to left OR top to bottom

  // TODO: Any sorting needs to happen here, else the min/max's might not line up correctly

  // First we need to find unique values, min/max values and negative/positive totals
  var uniqueVals = [];
  var min = void 0;
  var max = void 0;
  var datumValues = {};
  var negativeTotal = 0;
  var positiveTotal = 0;
  var domain = void 0;

  if (type === 'ordinal') {
    materializedData.forEach(function (series) {
      if (series[AxisIDKey] && series[AxisIDKey] !== id) {
        return;
      }
      var seriesValues = series.datums.map(function (d) {
        return d[valueKey];
      });
      seriesValues.forEach(function (d) {
        if (uniqueVals.indexOf(d) === -1) {
          uniqueVals.push(d);
        }
      });
    });
    domain = uniqueVals;
  } else if (type === 'time' || type === 'utc') {
    materializedData.forEach(function (series) {
      if (series[AxisIDKey] && series[AxisIDKey] !== id) {
        return;
      }
      var seriesValues = series.datums.map(function (d) {
        return +d[valueKey];
      });
      seriesValues.forEach(function (d, i) {
        var key = groupKey ? series.datums[i][groupKey] : i;
        datumValues[key] = [].concat(_toConsumableArray(datumValues[key] || []), [d]);
      });
      min = Math.min.apply(Math, _toConsumableArray(typeof min !== 'undefined' ? [min] : []).concat(_toConsumableArray(seriesValues)));
      max = Math.max.apply(Math, _toConsumableArray(typeof max !== 'undefined' ? [max] : []).concat(_toConsumableArray(seriesValues)));
    });
    domain = [min, max];
  } else {
    // Linear scale
    materializedData.forEach(function (series) {
      if (series[AxisIDKey] && series[AxisIDKey] !== id) {
        return;
      }
      var seriesValues = series.datums.map(function (d) {
        return d[valueKey];
      });
      seriesValues.forEach(function (d, i) {
        var key = groupKey ? series.datums[i][groupKey] : i;
        datumValues[key] = [].concat(_toConsumableArray(datumValues[key] || []), [d]);
      });
      seriesValues = seriesValues.filter(function (d) {
        return typeof d === 'number';
      });
      min = Math.min.apply(Math, _toConsumableArray(typeof min === 'number' ? [min] : []).concat(_toConsumableArray(seriesValues)));
      max = Math.max.apply(Math, _toConsumableArray(typeof max === 'number' ? [max] : []).concat(_toConsumableArray(seriesValues)));
    });
    if (stacked) {
      var _Object$keys$map$redu = Object.keys(datumValues).map(function (d) {
        return datumValues[d];
      }).reduce(function (totals, vals) {
        var positive = vals.filter(function (d) {
          return d >= 0;
        }).reduce(function (ds, d) {
          return ds + d;
        }, 0);
        var negative = vals.filter(function (d) {
          return d < 0;
        }).reduce(function (ds, d) {
          return ds + d;
        }, 0);
        return [positive > totals[0] ? positive : totals[0], negative < totals[1] ? negative : totals[1]];
      }, [0, 0]);
      // If we're stacking, calculate and use the max and min values for the largest stack


      var _Object$keys$map$redu2 = _slicedToArray(_Object$keys$map$redu, 2);

      positiveTotal = _Object$keys$map$redu2[0];
      negativeTotal = _Object$keys$map$redu2[1];

      domain = [negativeTotal, positiveTotal];
    } else {
      // If we're not stacking, use the min and max values
      domain = [min, max];
    }
  }

  // Now we need to figure out the range
  var range = vertical ? [height, 0] // If the axis is inverted, swap the range, too
  : [0, width];

  if (!primary) {
    // Secondary axes are usually dependent on primary axes for orientation, so if the
    // primaryAxis is in RTL mode, we need to reverse the range on this secondary axis
    // to match the origin of the primary axis
    var primaryAxis = primaryAxisID ? primaryAxes[primaryAxisID] : primaryAxes[0];
    if (primaryAxis.RTL) {
      range = [].concat(_toConsumableArray(range)).reverse();
    }
  }

  // Give the scale a home
  var scale = void 0;

  // If this is an ordinal or other primary axis, it needs to be able to display bars.
  var bandScale = void 0;
  var barSize = 0;
  var cursorSize = 0;
  var stepSize = 0;

  var seriesBandScale = function seriesBandScale(d) {
    return d;
  };
  var seriesBarSize = 1;

  if (type === 'ordinal' || primary) {
    // Calculate a band axis that is similar and pass down the bandwidth
    // just in case.
    bandScale = (0, _d3Scale.scaleBand)().domain(materializedData.reduce(function (prev, current) {
      return current.datums.length > prev.length ? current.datums : prev;
    }, []).map(function (d) {
      return d.primary;
    })).rangeRound(range, 0.1).padding(0);

    bandScale.paddingOuter(outerPadding).paddingInner(innerPadding);
    barSize = bandScale.bandwidth();

    if (type === 'ordinal') {
      cursorSize = barSize;
    }

    // barSize = bandScale.bandwidth()
    stepSize = bandScale.step();

    // Create a seriesBandScale in case this axis isn't stacked
    seriesBandScale = (0, _d3Scale.scaleBand)().paddingInner(innerPadding / 2).domain(materializedData.filter(function (d) {
      return d.Component.isBar;
    }).map(function (d, i) {
      return i;
    })).rangeRound([0, barSize]);

    seriesBarSize = seriesBandScale.bandwidth();
  }

  if (type === 'ordinal') {
    // If it's ordinal, just assign the bandScale we made
    scale = bandScale;
  } else {
    // Otherwise, create a new scale of the appropriate type
    scale = scales[type]();
  }

  // Set base, min, and max
  if (typeof base === 'number') {
    domain[0] = Math.min(domain[0], base);
    domain[1] = Math.max(domain[1], base);
  }
  if (typeof defaultMin === 'number') {
    domain[0] = Math.min(domain[0], defaultMin);
  }
  if (typeof defaultMax === 'number') {
    domain[1] = Math.max(domain[1], defaultMax);
  }

  // Set the domain
  scale.domain(domain);

  // If we're not using an ordinal scale, round the ticks to "nice" values
  if (type !== 'ordinal') {
    scale.nice();
  }

  // If hard min and max are set, override any "nice" rounding values
  if (typeof hardMin === 'number') {
    scale.domain([hardMin, scale.domain()[1]]);
  }
  if (typeof hardMax === 'number') {
    scale.domain([scale.domain()[0], hardMax]);
  }

  // Invert if necessary
  if (invert) {
    scale.domain([].concat(_toConsumableArray(scale.domain())).reverse());
  }

  // Now set the range
  scale.range(range);

  // Pass down the axis config (including the scale itself) for posterity
  var axis = {
    id: id,
    type: type,
    scale: scale,
    uniqueVals: uniqueVals,
    primary: primary,
    invert: invert,
    vertical: vertical,
    RTL: RTL,
    position: position,
    stacked: stacked,
    barSize: barSize,
    cursorSize: cursorSize,
    stepSize: stepSize,
    seriesBandScale: seriesBandScale,
    seriesBarSize: seriesBarSize,
    domain: domain,
    range: range,
    max: position === _AxisLinear.positionBottom ? -height : position === _AxisLinear.positionLeft ? width : position === _AxisLinear.positionTop ? height : -width,
    directionMultiplier: position === _AxisLinear.positionTop || position === _AxisLinear.positionLeft ? -1 : 1,
    transform: !vertical ? translateX : translateY,
    ticks: this.ticks = !tickValues ? scale.ticks ? (_scale = scale).ticks.apply(_scale, _toConsumableArray(tickArguments)) : scale.domain() : tickValues,
    format: !tickFormat ? scale.tickFormat ? (_scale2 = scale).tickFormat.apply(_scale2, _toConsumableArray(tickArguments)) : identity : tickFormat,
    spacing: Math.max(tickSizeInner, 0) + tickPadding
  };

  if (type === 'ordinal') {
    axis.gridOffset = -(axis.stepSize * innerPadding) / 2;
    axis.tickOffset = axis.barSize / 2;
    axis.barOffset = 0;
  } else {
    axis.tickOffset = 0;
    axis.barOffset = -axis.barSize / 2;
  }

  // Make sure we start with a prevAxis
  this.prevAxis = this.prevAxis || axis;

  this.props.dispatch(function (state) {
    return _extends({}, state, {
      axes: _extends({}, state.axes, _defineProperty({}, id, axis))
    });
  });
}

function identity(x) {
  return x;
}

function translateX(x) {
  return 'translate3d(' + x + 'px, 0, 0)';
}

function translateY(y) {
  return 'translate3d(0, ' + y + 'px, 0)';
}