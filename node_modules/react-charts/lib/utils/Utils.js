'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _raf = require('raf');

var _raf2 = _interopRequireDefault(_raf);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  requestAnimationFrame: _raf2.default,
  throttle: throttle,
  getStatus: getStatus,
  getStatusStyle: getStatusStyle,
  getMultiFocus: getMultiFocus,
  getClosestPoint: getClosestPoint,
  normalizeComponent: normalizeComponent,
  materializeStyles: materializeStyles,
  normalizeGetter: normalizeGetter,
  normalizePathGetter: normalizePathGetter,
  isArray: isArray,
  isValidPoint: isValidPoint,
  getAxisByAxisID: getAxisByAxisID,
  getAxisIndexByAxisID: getAxisIndexByAxisID,
  shallowCompare: shallowCompare
};


function throttle(func) {
  var running = void 0;
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (running) return;
    running = (0, _raf2.default)(function () {
      func.apply(undefined, args);
      running = false;
    });
  };
}

function getStatus(item, hovered, selected) {
  var status = {
    selected: false,
    hovered: false,
    otherSelected: false,
    otherHovered: false
  };

  if (item.series) {
    var d = void 0;
    if (selected && selected.active && selected.datums) {
      for (var i = 0; i < selected.datums.length; i++) {
        d = selected.datums[i];
        if (d.seriesID === item.series.id && d.index === item.index) {
          status.selected = true;
          break;
        }
      }
      status.otherSelected = !status.selected;
    }
    if (hovered && hovered.active && hovered.datums) {
      for (var _i = 0; _i < hovered.datums.length; _i++) {
        d = hovered.datums[_i];
        if (d.seriesID === item.series.id && d.index === item.index) {
          status.hovered = true;
          break;
        }
      }
      status.otherHovered = !status.hovered;
    }
  } else {
    if (selected && selected.active && selected.series) {
      status.selected = selected.series.id === item.id;
      status.otherSelected = !status.selected;
    }
    if (hovered && hovered.active && hovered.series) {
      status.hovered = hovered.series.id === item.id;
      status.otherHovered = !status.hovered;
    }
  }

  return status;
}

function getStatusStyle(item, status, decorator, defaults) {
  if (item.series) {
    defaults = _extends({}, defaults, item.series.style);
  }

  return materializeStyles(decorator(_extends({}, item, status)), defaults);
}

function getMultiFocus(_ref) {
  var focus = _ref.focus,
      points = _ref.points,
      gridX = _ref.gridX,
      gridY = _ref.gridY,
      gridWidth = _ref.gridWidth,
      gridHeight = _ref.gridHeight,
      width = _ref.width,
      height = _ref.height;

  var invalid = function invalid() {
    throw new Error(JSON.stringify(focus) + ' is not a valid tooltip focus option. You should use a single focus option or 2 non-conflicting focus options.');
  };

  var x = void 0;
  var y = void 0;

  var xMin = points[0].focus.x;
  var xMax = points[0].focus.x;
  var yMin = points[0].focus.y;
  var yMax = points[0].focus.y;

  points.forEach(function (point) {
    xMin = Math.min(point.focus.x, xMin);
    xMax = Math.max(point.focus.x, xMax);
    yMin = Math.min(point.focus.y, yMin);
    yMax = Math.max(point.focus.y, yMax);
  });

  if (focus.length > 2) {
    return invalid();
  }

  focus = focus.sort(function (a) {
    return a.includes('center') || a.includes('Center') ? 1 : -1;
  });

  for (var i = 0; i < focus.length; i++) {
    var focusPart = focus[i];

    // Horizontal Positioning
    if (['left', 'right', 'gridLeft', 'gridRight', 'chartLeft', 'chartRight'].includes(focusPart)) {
      if (typeof x !== 'undefined') {
        invalid();
      }
      if (focusPart === 'left') {
        x = xMin;
      } else if (focusPart === 'right') {
        x = xMax;
      } else if (focusPart === 'gridLeft') {
        x = gridX;
      } else if (focusPart === 'gridRight') {
        x = gridX + gridWidth;
      } else if (focusPart === 'chartLeft') {
        x = 0;
      } else if (focusPart === 'chartRight') {
        x = width;
      } else {
        invalid();
      }
    }

    // Vertical Positioning
    if (['top', 'bottom', 'gridTop', 'gridBottom', 'chartTop', 'chartBottom'].includes(focusPart)) {
      if (typeof y !== 'undefined') {
        invalid();
      }
      if (focusPart === 'top') {
        y = yMin;
      } else if (focusPart === 'bottom') {
        y = yMax;
      } else if (focusPart === 'gridTop') {
        y = gridY;
      } else if (focusPart === 'gridBottom') {
        y = gridY + gridHeight;
      } else if (focusPart === 'chartTop') {
        y = 0;
      } else if (focusPart === 'chartBottom') {
        y = height;
      } else {
        invalid();
      }
    }

    // Center Positioning
    if (['center', 'gridCenter', 'chartCenter'].includes(focusPart)) {
      if (focusPart === 'center') {
        if (typeof y === 'undefined') {
          y = (yMin + yMax) / 2;
        }
        if (typeof x === 'undefined') {
          x = (xMin + xMax) / 2;
        }
      } else if (focusPart === 'gridCenter') {
        if (typeof y === 'undefined') {
          y = gridY + gridHeight / 2;
        }
        if (typeof x === 'undefined') {
          x = gridX + gridWidth / 2;
        }
      } else if (focusPart === 'chartCenter') {
        if (typeof y === 'undefined') {
          y = height / 2;
        }
        if (typeof x === 'undefined') {
          x = width / 2;
        }
      } else {
        invalid();
      }
    }

    // Auto center the remainder if there is only one focusPart listed
    if (focus.length === 1) {
      if (focus[0].includes('grid')) {
        focus.push('gridCenter');
      } else if (focus[0].includes('chart')) {
        focus.push('chartCenter');
      } else {
        focus.push('center');
      }
    }
  }

  return { x: x, y: y };
}

function getClosestPoint(position, datums) {
  if (!datums || !position || !datums.length) {
    return;
  }
  var closestDistance = Infinity;
  var closestDatum = datums[0];
  datums.forEach(function (datum) {
    datum.pointerPoints.forEach(function (pointerPoint) {
      var distance = Math.sqrt(Math.pow(pointerPoint.x - position.x, 2) + Math.pow(pointerPoint.y - position.y, 2));
      if (distance < closestDistance) {
        closestDistance = distance;
        closestDatum = datum;
      }
    });
  });
  return closestDatum;
}

function normalizeComponent(Comp) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Comp;

  return typeof Comp === 'function' ? Object.getPrototypeOf(Comp).isReactComponent ? _react2.default.createElement(Comp, params) : Comp(params) : fallback;
}

function normalizeColor(style, defaults) {
  return _extends({}, style, {
    stroke: style.stroke || style.color || defaults.stroke || defaults.color,
    fill: style.fill || style.color || defaults.fill || defaults.color
  });
}

function materializeStyles() {
  var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var defaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  style = normalizeColor(style, defaults);
  ['area', 'line', 'rectangle', 'circle'].forEach(function (type) {
    style[type] = style[type] ? materializeStyles(style[type], defaults) : {};
  });
  return style;
}

function normalizeGetter(getter) {
  if (!getter) {
    return;
  }
  if (typeof getter === 'function') {
    return getter;
  }
  return function () {
    return getter;
  };
}

function normalizePathGetter(getter) {
  if (typeof getter === 'function') {
    return getter;
  }
  return function (d) {
    return get(d, getter);
  };
}

function get(obj, path, def) {
  if (typeof obj === 'function') {
    try {
      return obj();
    } catch (e) {
      return path;
    }
  }
  if (!path) {
    return obj;
  }
  var pathObj = makePathArray(path);
  var val = void 0;
  try {
    val = pathObj.reduce(function (current, pathPart) {
      return current[pathPart];
    }, obj);
  } catch (e) {
    // do nothing
  }
  return typeof val !== 'undefined' ? val : def;
}

function isArray(a) {
  return Array.isArray(a);
}

function makePathArray(obj) {
  return flattenDeep(obj).join('.').replace('[', '.').replace(']', '').split('.');
}

function flattenDeep(arr) {
  var newArr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (!isArray(arr)) {
    newArr.push(arr);
  } else {
    for (var i = 0; i < arr.length; i++) {
      flattenDeep(arr[i], newArr);
    }
  }
  return newArr;
}

function isValidPoint(d) {
  if (d === null) {
    return false;
  }
  if (typeof d === 'undefined') {
    return false;
  }
  if (typeof d === 'string' && d === 'null') {
    return false;
  }
  return true;
}

function getAxisByAxisID(axes, AxisID) {
  return axes.find(function (d) {
    return d.id === AxisID;
  }) || axes[0];
}

function getAxisIndexByAxisID(axes, AxisID) {
  var index = axes.findIndex(function (d) {
    return d.id === AxisID;
  });
  return index > -1 ? index : 0;
}

function shallowCompare() {
  var old = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var _new = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var props = arguments[2];
  var ignore = arguments[3];

  if (!props) {
    props = {};
    Object.keys(old).forEach(function (key) {
      props[key] = true;
    });
    Object.keys(_new).forEach(function (key) {
      props[key] = true;
    });
    props = Object.keys(props);
  }
  if (ignore) {
    for (var i = 0; i < props.length; i++) {
      if (!ignore.includes(props[i])) {
        if (old[props[i]] !== _new[props[i]]) {
          return props[i] || true;
        }
      }
    }
  } else {
    for (var _i2 = 0; _i2 < props.length; _i2++) {
      if (old[props[_i2]] !== _new[props[_i2]]) {
        return props[_i2] || true;
      }
    }
  }
  return false;
}