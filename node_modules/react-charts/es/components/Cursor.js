'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _ReactMove = require('./ReactMove');

var _Context = require('../utils/Context');

var _Selectors = require('../utils/Selectors');

var _Selectors2 = _interopRequireDefault(_Selectors);

var _Utils = require('../utils/Utils');

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//


var getLineBackgroundColor = function getLineBackgroundColor(dark) {
  return dark ? 'rgba(255,255,255,.3)' : 'rgba(0, 26, 39, 0.3)';
};
var getBackgroundColor = function getBackgroundColor(dark) {
  return dark ? 'rgba(255,255,255,.9)' : 'rgba(0, 26, 39, 0.9)';
};

var Cursor = function (_React$PureComponent) {
  _inherits(Cursor, _React$PureComponent);

  function Cursor() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Cursor);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Cursor.__proto__ || Object.getPrototypeOf(Cursor)).call.apply(_ref, [this].concat(args))), _this), _this.prevValue = null, _this.updateCursor = function () {
      var _this$props = _this.props,
          primary = _this$props.primary,
          snap = _this$props.snap,
          axisID = _this$props.axisID,
          onChange = _this$props.onChange,
          cursor = _this$props.cursor,
          stackData = _this$props.stackData,
          primaryAxes = _this$props.primaryAxes,
          secondaryAxes = _this$props.secondaryAxes,
          pointer = _this$props.pointer,
          hovered = _this$props.hovered,
          gridWidth = _this$props.gridWidth,
          gridHeight = _this$props.gridHeight,
          dispatch = _this$props.dispatch;

      // Don't render until we have all dependencies

      if (!stackData || !primaryAxes.length || !secondaryAxes.length) {
        return null;
      }

      var resolvedCursor = cursor || { value: null };

      var _resolvedCursor$value = resolvedCursor.value,
          value = _resolvedCursor$value === undefined ? null : _resolvedCursor$value,
          datum = resolvedCursor.datum;

      var x = void 0;
      var y = void 0;
      var show = false;

      var resolvedAxisID = axisID || datum && datum.series && datum.series[(primary ? 'primary' : 'secondary') + 'AxisID'];

      // Determine the axis to use
      var axis = _Utils2.default.getAxisByAxisID(primary ? primaryAxes : secondaryAxes, resolvedAxisID);
      var siblingAxis = primary ? secondaryAxes[0] : primaryAxes[0];

      // Resolve the invert function
      var invert = axis.scale.invert || function (d) {
        return d;
      };

      // If the cursor isn't in the grid, don't display
      if (pointer.active) {
        // Default to cursor x and y
        show = true;

        if (pointer.x < -1 || pointer.x > gridWidth + 1 || pointer.y < -1 || pointer.y > gridHeight + 1) {
          show = false;
        }

        // Implement snapping
        if (axis.type === 'ordinal' || snap) {
          // For snapping we need the hovered datums
          if (!hovered || !hovered.datums || !hovered.datums.length) {
            return;
          }

          datum = _Utils2.default.getClosestPoint(pointer, hovered.datums);

          if (axis.vertical) {
            value = datum.yValue;
          } else {
            value = datum.xValue;
          }
        } else if (axis.vertical) {
          value = invert(y);
        } else {
          value = invert(x);
        }
      } else {
        show = false;
        datum = {};
      }

      var newCursor = {
        axis: axis,
        siblingAxis: siblingAxis,
        value: show ? value : null,
        datum: datum
      };

      if ((resolvedCursor && resolvedCursor.value) !== newCursor.value) {
        onChange(newCursor);
      }

      dispatch(function (state) {
        return _extends({}, state, {
          cursors: _extends({}, state.cursors, _defineProperty({}, primary ? 'primary' : 'secondary', newCursor))
        });
      });
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Cursor, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.updateCursor();
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prev) {
      if (_Utils2.default.shallowCompare(prev, this.props, ['pointer', 'hovered', 'stackData', 'primaryAxes', 'secondaryAxes'])) {
        this.updateCursor();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          showLine = _props.showLine,
          showLabel = _props.showLabel,
          manualValue = _props.value,
          primary = _props.primary,
          snap = _props.snap,
          cursor = _props.cursor,
          _props$offset = _props.offset,
          left = _props$offset.left,
          top = _props$offset.top,
          gridX = _props.gridX,
          gridY = _props.gridY,
          gridWidth = _props.gridWidth,
          gridHeight = _props.gridHeight,
          dark = _props.dark,
          render = _props.render,
          children = _props.children,
          Comp = _props.Component;


      if (!cursor) {
        return null;
      }

      var axis = cursor.axis,
          siblingAxis = cursor.siblingAxis,
          value = cursor.value,
          datum = cursor.datum;

      // Is the value manually set via the value prop?

      var isManual = typeof manualValue !== 'undefined';
      // Resolve the value from manual or the cursor info
      var resolvedValue = isManual ? manualValue : value;
      // Should we animate?
      var animated = snap || axis.type === 'ordinal';

      // Get the sibling range
      var siblingRange = siblingAxis.scale.range();

      // Set the opacity
      var opacity = _Utils2.default.isValidPoint(resolvedValue) ? 1 : 0;

      // Fall back to the last value for coordinates
      resolvedValue = _Utils2.default.isValidPoint(resolvedValue) ? resolvedValue : this.prevValue;

      // Store the latest valid resolvedValue
      if (_Utils2.default.isValidPoint(resolvedValue)) {
        this.prevValue = resolvedValue;
      }

      var x = void 0;
      var y = void 0;
      var x1 = void 0;
      var x2 = void 0;
      var y1 = void 0;
      var y2 = void 0;
      var alignPctX = void 0;
      var alignPctY = void 0;

      // Vertical alignment
      if (axis.vertical) {
        y = axis.scale(resolvedValue);
        x1 = siblingRange[0];
        x2 = siblingRange[1];
        y1 = y - 1;
        y2 = y + axis.cursorSize + 1;
        if (axis.position === 'left') {
          alignPctX = -100;
          alignPctY = -50;
        } else {
          alignPctX = 0;
          alignPctY = -50;
        }
      } else {
        x = axis.scale(resolvedValue);
        x1 = x - 1;
        x2 = x + axis.cursorSize + 1;
        y1 = siblingRange[0];
        y2 = siblingRange[1];
        if (axis.position === 'top') {
          alignPctX = -500;
          alignPctY = -100;
        } else {
          alignPctX = -50;
          alignPctY = 0;
        }
      }

      // If the cursor isn't in the grid, don't display
      if (x < -1 || x > gridWidth + 1 || y < -1 || y > gridHeight + 1) {
        opacity = 0;
      }

      var renderProps = {
        axis: axis,
        datum: datum,
        value: resolvedValue,
        primary: primary
      };

      renderProps.formattedValue = axis.vertical ? typeof value !== 'undefined' ? axis.format(axis.stacked && !primary ? datum.totalValue : value) : '' : typeof value !== 'undefined' ? axis.format(axis.stacked && !primary ? datum.totalValue : value) : '';

      var lineStartX = Math.min(x1, x2);
      var lineStartY = Math.min(y1, y2);
      var lineEndX = Math.max(x1, x2);
      var lineEndY = Math.max(y1, y2);
      var bubbleX = axis.vertical && axis.RTL ? lineEndX : x1 + (!axis.vertical ? (x2 - x1) / 2 : 0) + (!axis.vertical ? 1 : 0);
      var bubbleY = !axis.vertical && axis.RTL ? lineStartY : y1 + (axis.vertical ? (y2 - y1) / 2 : 0) + (axis.vertical ? 1 : 0);

      var lineHeight = Math.max(lineEndY - lineStartY, 0);
      var lineWidth = Math.max(lineEndX - lineStartX, 0);

      var start = {
        transform: 'translate3d(' + (left + gridX) + 'px, ' + (top + gridY) + 'px, 0)',
        opacity: 0
      };

      var update = {
        transform: 'translate3d(' + (left + gridX) + 'px, ' + (top + gridY) + 'px, 0)',
        opacity: opacity
      };

      var renderedChildren = void 0;

      if (Comp) {
        renderedChildren = _react2.default.createElement(Comp, null, renderProps);
      } else {
        renderedChildren = (render || children)(renderProps);
      }

      return _react2.default.createElement(
        _ReactMove.Animate,
        {
          show: !!opacity,
          start: start,
          enter: update,
          update: update,
          leave: update,
          style: {
            pointerEvents: 'none',
            position: 'absolute',
            top: 0,
            left: 0
          },
          className: 'Cursor'
        },
        showLine ? _react2.default.createElement('div', {
          style: {
            position: 'absolute',
            top: 0,
            left: 0,
            transform: 'translate3d(' + lineStartX + 'px, ' + lineStartY + 'px, 0px)',
            width: lineWidth + 'px',
            height: lineHeight + 'px',
            background: getLineBackgroundColor(dark),
            WebkitBackfaceVisibility: 'hidden',
            transition: animated ? '.2s all ease-out' : 'none'
          }
        }) : null,
        showLabel ? _react2.default.createElement(
          'div',
          {
            style: {
              position: 'absolute',
              top: 0,
              left: 0,
              transform: 'translate3d(' + bubbleX + 'px, ' + bubbleY + 'px, 0px)',
              transition: animated ? '.2s all ease-out' : 'none'
            }
          },
          _react2.default.createElement(
            'div',
            {
              style: {
                padding: '5px',
                fontSize: '10px',
                background: getBackgroundColor(dark),
                color: dark ? 'black' : 'white',
                borderRadius: '3px',
                position: 'relative',
                transform: 'translate3d(' + alignPctX + '%, ' + alignPctY + '%, 0px)',
                whiteSpace: 'nowrap'
              }
            },
            renderedChildren
          )
        ) : null
      );
    }
  }]);

  return Cursor;
}(_react2.default.PureComponent);

Cursor.defaultProps = {
  children: function children(_ref2) {
    var axis = _ref2.axis,
        value = _ref2.value,
        formattedValue = _ref2.formattedValue,
        datum = _ref2.datum,
        primary = _ref2.primary;
    return _react2.default.createElement(
      'span',
      null,
      formattedValue
    );
  },
  snap: true,
  showLine: true,
  showLabel: true,
  axisID: undefined,
  onChange: function onChange() {}
};
Cursor.isHtml = true;
exports.default = (0, _Context.PointerConnect)(function (state) {
  return {
    pointer: state.pointer
  };
})((0, _Context.ChartConnect)(function () {
  var selectors = {
    primaryAxes: _Selectors2.default.primaryAxes(),
    secondaryAxes: _Selectors2.default.secondaryAxes(),
    offset: _Selectors2.default.offset(),
    gridHeight: _Selectors2.default.gridHeight(),
    gridWidth: _Selectors2.default.gridWidth(),
    gridX: _Selectors2.default.gridX(),
    gridY: _Selectors2.default.gridY()
  };
  return function (state, props) {
    return {
      stackData: state.stackData,
      cursor: state.cursors[props.primary ? 'primary' : 'secondary'],
      hovered: state.hovered,
      primaryAxes: selectors.primaryAxes(state),
      secondaryAxes: selectors.secondaryAxes(state),
      offset: selectors.offset(state),
      gridHeight: selectors.gridHeight(state),
      gridWidth: selectors.gridWidth(state),
      gridX: selectors.gridX(state),
      gridY: selectors.gridY(state),
      dark: state.dark
    };
  };
})(Cursor));