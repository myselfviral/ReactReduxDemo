'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Context = require('../utils/Context');

var _Utils = require('../utils/Utils');

var _Utils2 = _interopRequireDefault(_Utils);

var _Selectors = require('../utils/Selectors');

var _Selectors2 = _interopRequireDefault(_Selectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//

var debug = process.env.NODE_ENV === 'development';

var defaultColors = ['#4ab5eb', '#fc6868', '#DECF3F', '#60BD68', '#FAA43A', '#c63b89', '#1aaabe', '#734fe9', '#1828bd', '#cd82ad'];

var modePrimary = 'primary';
var modeSecondary = 'secondary';

var getType = function getType(type, data, i) {
  // Allow dynamic types
  var typeGetter = typeof type === 'function' && type.prototype.isReactComponent ? function () {
    return type;
  } : type;
  return typeGetter(data, i);
};

var Series = function (_React$Component) {
  _inherits(Series, _React$Component);

  function Series() {
    _classCallCheck(this, Series);

    return _possibleConstructorReturn(this, (Series.__proto__ || Object.getPrototypeOf(Series)).apply(this, arguments));
  }

  _createClass(Series, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.updateMaterializedData(this.props);
      this.updateStackData(this.props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(oldProps) {
      // If any of the following change,
      // we need to update the materializedData
      if (_Utils2.default.shallowCompare(oldProps, this.props, ['type', 'preMaterializedData'])) {
        return this.updateMaterializedData(this.props);
      }

      // If any of the following change,
      // we need to update the stack
      if (_Utils2.default.shallowCompare(oldProps, this.props, ['materializedData', 'axes', 'seriesKey', 'primaryAxes', 'secondaryAxes', 'groupMode'])) {
        this.updateStackData(this.props);
      }
    }
  }, {
    key: 'updateMaterializedData',
    value: function updateMaterializedData(props) {
      var preMaterializedData = props.preMaterializedData,
          type = props.type,
          dispatch = props.dispatch;

      // We need preMaterializedData to proceed

      if (!preMaterializedData) {
        return;
      }

      dispatch(function (state) {
        return _extends({}, state, {
          materializedData: preMaterializedData.map(function (series, index) {
            var SeriesComponent = getType(type, series, index);
            if (debug && !SeriesComponent) {
              console.error(series);
              throw new Error('An invalid series component was passed for the series above (index: ' + index + '.');
            }
            return _extends({}, series, {
              Component: SeriesComponent
            });
          }).map(function (series, i, all) {
            var seriesTypeIndex = all.filter(function (d, j) {
              return j < i && d.Component === series.Component;
            }).length;
            return _extends({}, series, {
              seriesTypeIndex: seriesTypeIndex,
              datums: series.datums.map(function (datum) {
                return _extends({}, datum, {
                  seriesTypeIndex: seriesTypeIndex
                });
              })
            });
          })
        });
      });
    }
  }, {
    key: 'updateStackData',
    value: function updateStackData(props) {
      var _this2 = this;

      var materializedData = props.materializedData,
          primaryAxes = props.primaryAxes,
          secondaryAxes = props.secondaryAxes,
          groupMode = props.groupMode;

      // We need materializedData and both axes to continue

      if (!materializedData || !primaryAxes.length || !secondaryAxes.length) {
        return;
      }

      // If the axes are ready, let's decorate the materializedData for visual plotting
      // const secondaryStacked = secondaryAxes.stacked

      // Make sure we're mapping x and y to the correct axes
      var xKey = primaryAxes.find(function (d) {
        return d.vertical;
      }) ? 'secondary' : 'primary';
      var yKey = primaryAxes.find(function (d) {
        return d.vertical;
      }) ? 'primary' : 'secondary';
      var xAxes = primaryAxes.find(function (d) {
        return d.vertical;
      }) ? secondaryAxes : primaryAxes;
      var yAxes = primaryAxes.find(function (d) {
        return d.vertical;
      }) ? primaryAxes : secondaryAxes;

      // "totals" are kept per secondaryAxis and used for bases if secondaryAxis stacking is enabled
      var scaleTotals = secondaryAxes.map(function () {
        return {};
      });
      materializedData.forEach(function (series) {
        var axisIndex = _Utils2.default.getAxisIndexByAxisID(secondaryAxes, series.secondaryAxisID);
        series.datums.forEach(function (datum) {
          scaleTotals[axisIndex][datum.primary] = {
            negative: 0,
            positive: 0
          };
        });
      });

      // Determine the correct primary and secondary values for each axis
      // Also calculate bases and totals if either axis is stacked
      var stackData = materializedData.map(function (series) {
        var primaryAxisIndex = _Utils2.default.getAxisIndexByAxisID(primaryAxes, series.primaryAxisID);
        var primaryAxis = primaryAxes[primaryAxisIndex];
        var secondaryAxisIndex = _Utils2.default.getAxisIndexByAxisID(secondaryAxes, series.secondaryAxisID);
        var secondaryAxis = secondaryAxes[secondaryAxisIndex];
        return _extends({}, series, {
          datums: series.datums.map(function (d) {
            var datum = _extends({}, d, {
              xValue: d[xKey],
              yValue: d[yKey],
              baseValue: 0
            });
            if (secondaryAxis.stacked) {
              var start = scaleTotals[secondaryAxisIndex][d.primary];
              // Stack the x or y values (according to axis positioning)
              if (primaryAxis.vertical) {
                // Is this a valid point?
                var validPoint = _Utils2.default.isValidPoint(datum.xValue);
                // Should we use positive or negative base?
                var totalKey = datum.xValue >= 0 ? 'positive' : 'negative';
                // Assign the base
                datum.baseValue = start[totalKey];
                // Add the value for a total
                datum.totalValue = datum.baseValue + (validPoint ? datum.xValue : 0);
                // Update the totals
                scaleTotals[secondaryAxisIndex][d.primary][totalKey] = datum.totalValue;
                // Make the total the new value
                datum.xValue = validPoint ? datum.totalValue : null;
              } else {
                // Is this a valid point?
                var _validPoint = _Utils2.default.isValidPoint(datum.yValue);
                // Should we use positive or negative base?
                var _totalKey = datum.yValue >= 0 ? 'positive' : 'negative';
                // Assign the base
                datum.baseValue = start[_totalKey];
                // Add the value to the base
                datum.totalValue = datum.baseValue + (_validPoint ? datum.yValue : 0);
                // Update the totals
                scaleTotals[secondaryAxisIndex][d.primary][_totalKey] = datum.totalValue;
                // Make the total the new value
                datum.yValue = _validPoint ? datum.totalValue : null;
              }
            }
            return datum;
          })
        });
      });

      stackData.forEach(function (series) {
        series.datums.forEach(function (datum) {
          datum.series = series;
        });
      });

      // Use the plotDatum method on each series
      stackData.forEach(function (series, i) {
        if (debug && !series.Component.plotDatum) {
          throw new Error('Could not find a [SeriesType].plotDatum() static method for the series Component above (index: ' + i + ')');
        }

        var primaryAxisIndex = _Utils2.default.getAxisIndexByAxisID(primaryAxes, series.primaryAxisID);
        var primaryAxis = primaryAxes[primaryAxisIndex];
        var secondaryAxisIndex = _Utils2.default.getAxisIndexByAxisID(secondaryAxes, series.secondaryAxisID);
        var secondaryAxis = secondaryAxes[secondaryAxisIndex];
        var xAxisIndex = _Utils2.default.getAxisIndexByAxisID(xAxes, series[xKey + 'AxisID']);
        var xAxis = xAxes[xAxisIndex];
        var yAxisIndex = _Utils2.default.getAxisIndexByAxisID(yAxes, series[yKey + 'AxisID']);
        var yAxis = yAxes[yAxisIndex];

        series.datums = series.datums.map(function (d) {
          // Data for cartesian charts
          var result = series.Component.plotDatum(d, {
            primaryAxis: primaryAxis,
            secondaryAxis: secondaryAxis,
            xAxis: xAxis,
            yAxis: yAxis
          });

          return result || d;
        });
      });

      // Do any data grouping ahead of time
      if ([modePrimary, modeSecondary].includes(groupMode)) {
        var datumsByGrouping = {};

        stackData.forEach(function (series) {
          series.datums.filter(function (d) {
            return d.defined;
          }).forEach(function (datum) {
            var axisKey = String(groupMode === modePrimary ? datum.primary : datum.secondary);

            datumsByGrouping[axisKey] = datumsByGrouping[axisKey] || [];
            datumsByGrouping[axisKey].push(datum);
          });
        });

        stackData.forEach(function (series) {
          series.datums.forEach(function (datum) {
            var axisKey = String(groupMode === modePrimary ? datum.primary : datum.secondary);

            datum.group = datumsByGrouping[axisKey];
          });
        });
      }

      // Not we need to precalculate all of the possible status styles by
      // calling the seemingly 'live' getStyles, and getDatumStyles callbacks ;)
      stackData = stackData.map(function (series, i) {
        if (debug && !series.Component.buildStyles) {
          throw new Error('Could not find a SeriesType.buildStyles() static method for the series Component above (index: ' + i + ')');
        }
        var result = series.Component.buildStyles(series, {
          // Make sure we are using a thunk to get the most recent getStyles and getDatumStyles
          getStyles: function getStyles() {
            var _props;

            return (_props = _this2.props).getStyles.apply(_props, arguments);
          },
          getDatumStyles: function getDatumStyles() {
            var _props2;

            return (_props2 = _this2.props).getDatumStyles.apply(_props2, arguments);
          },
          defaultColors: defaultColors
        });

        return result || series;
      });

      this.props.dispatch(function (state) {
        return _extends({}, state, {
          stackData: stackData
        });
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _props3 = this.props,
          type = _props3.type,
          getStyles = _props3.getStyles,
          getDatumStyles = _props3.getDatumStyles,
          stackData = _props3.stackData,
          rest = _objectWithoutProperties(_props3, ['type', 'getStyles', 'getDatumStyles', 'stackData']);

      if (!stackData) {
        return null;
      }

      var reversedStackData = [].concat(_toConsumableArray(stackData)).reverse(); // For proper svg stacking

      return _react2.default.createElement(
        'g',
        { className: 'Series' },
        reversedStackData.map(function (stack) {
          var StackCmp = getType(type, stack, stack.id);
          return _react2.default.createElement(StackCmp, _extends({}, rest, { key: stack.id, series: stack, stackData: stackData }));
        })
      );
    }
  }]);

  return Series;
}(_react2.default.Component);

Series.defaultProps = {
  getStyles: function getStyles() {
    return {};
  },
  getDatumStyles: function getDatumStyles() {
    return {};
  }
};
exports.default = (0, _Context.ChartConnect)(function () {
  var selectors = {
    primaryAxes: _Selectors2.default.primaryAxes(),
    secondaryAxes: _Selectors2.default.secondaryAxes()
  };
  return function (state) {
    return {
      primaryAxes: selectors.primaryAxes(state),
      secondaryAxes: selectors.secondaryAxes(state),
      preMaterializedData: state.preMaterializedData,
      materializedData: state.materializedData,
      stackData: state.stackData,
      tooltip: state.tooltip,
      hovered: state.hovered,
      selected: state.selected,
      groupMode: state.groupMode
    };
  };
})(Series);