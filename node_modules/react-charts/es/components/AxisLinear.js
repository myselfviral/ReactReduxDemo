'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.positionLeft = exports.positionBottom = exports.positionRight = exports.positionTop = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _raf = require('raf');

var _raf2 = _interopRequireDefault(_raf);

var _Context = require('../utils/Context');

var _Utils = require('../utils/Utils');

var _Utils2 = _interopRequireDefault(_Utils);

var _AxisLinear = require('./AxisLinear.measure');

var _AxisLinear2 = _interopRequireDefault(_AxisLinear);

var _AxisLinear3 = require('./AxisLinear.updateScale');

var _AxisLinear4 = _interopRequireDefault(_AxisLinear3);

var _Path = require('../primitives/Path');

var _Path2 = _interopRequireDefault(_Path);

var _Line = require('../primitives/Line');

var _Line2 = _interopRequireDefault(_Line);

var _Text = require('../primitives/Text');

var _Text2 = _interopRequireDefault(_Text);

var _Group = require('../primitives/Group');

var _Group2 = _interopRequireDefault(_Group);

var _Selectors = require('../utils/Selectors');

var _Selectors2 = _interopRequireDefault(_Selectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//


var positionTop = exports.positionTop = 'top';
var positionRight = exports.positionRight = 'right';
var positionBottom = exports.positionBottom = 'bottom';
var positionLeft = exports.positionLeft = 'left';

var defaultStyles = {
  line: {
    strokeWidth: '1',
    fill: 'transparent'
  },
  tick: {
    fontSize: 10,
    fontFamily: 'sans-serif'
  }
};

var Axis = function (_React$Component) {
  _inherits(Axis, _React$Component);

  function Axis() {
    _classCallCheck(this, Axis);

    var _this = _possibleConstructorReturn(this, (Axis.__proto__ || Object.getPrototypeOf(Axis)).call(this));

    _this.state = {
      rotation: 0
    };
    _this.measure = _Utils2.default.throttle(_AxisLinear2.default.bind(_this));
    _this.measureRotation = _Utils2.default.throttle(_AxisLinear2.default.bind(_this));
    _this.updateScale = _AxisLinear4.default.bind(_this);
    return _this;
  }

  _createClass(Axis, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.updateScale(this.props);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(oldProps, oldState) {
      if (oldProps.axis !== this.props.axis && oldProps.axis) {
        this.prevAxis = oldProps.axis;
      }

      // If any of the following changed,
      // we need to update the axis
      if (!this.props.axis && this.props.primaryAxes !== oldProps.primaryAxes || this.props.primary !== oldProps.primary || this.props.type !== oldProps.type || this.props.invert !== oldProps.invert || this.props.materializedData !== oldProps.materializedData || this.props.height !== oldProps.height || this.props.width !== oldProps.width || this.props.position !== oldProps.position || this.props.min !== oldProps.min || this.props.max !== oldProps.max || this.props.hardMin !== oldProps.hardMin || this.props.hardMax !== oldProps.hardMax) {
        this.updateScale(this.props);
      }

      if (this.props.axis !== oldProps.axis || oldState.rotation !== this.state.rotation) {
        this.measure();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          type = _props.type,
          axis = _props.axis,
          position = _props.position,
          width = _props.width,
          height = _props.height,
          tickSizeInner = _props.tickSizeInner,
          tickSizeOuter = _props.tickSizeOuter,
          show = _props.show,
          showGrid = _props.showGrid,
          showTicks = _props.showTicks,
          styles = _props.styles,
          dark = _props.dark;
      var rotation = this.state.rotation;

      // Combine default styles with style props

      var axisStyles = _extends({}, defaultStyles, styles);

      // Render Dependencies
      if (!axis || !show) {
        return null;
      }

      var scale = axis.scale,
          max = axis.max,
          transform = axis.transform,
          vertical = axis.vertical,
          format = axis.format,
          ticks = axis.ticks,
          _axis$range = _slicedToArray(axis.range, 2),
          range0 = _axis$range[0],
          range1 = _axis$range[1],
          directionMultiplier = axis.directionMultiplier,
          tickOffset = axis.tickOffset,
          gridOffset = axis.gridOffset,
          spacing = axis.spacing;

      var axisPath = void 0;
      if (vertical) {
        if (position === positionLeft) {
          axisPath = '\n                M ' + -tickSizeOuter + ', ' + range0 + '\n                H 0\n                V ' + range1 + '\n                H ' + -tickSizeOuter + '\n              ';
        } else {
          axisPath = '\n                M ' + tickSizeOuter + ', ' + range0 + '\n                H 0\n                V ' + range1 + '\n                H ' + tickSizeOuter + '\n              ';
        }
      } else if (position === positionBottom) {
        axisPath = '\n                M 0, ' + tickSizeOuter + '\n                V 0\n                H ' + range1 + '\n                V ' + tickSizeOuter + '\n              ';
      } else {
        axisPath = '\n                M 0, ' + -tickSizeOuter + '\n                V 0\n                H ' + range1 + '\n                V ' + -tickSizeOuter + '\n              ';
      }

      var showGridLine = void 0;
      if (typeof showGrid === 'boolean') {
        showGridLine = showGrid;
      } else if (type === 'ordinal') {
        showGridLine = false;
      } else {
        showGridLine = true;
      }

      return _react2.default.createElement(
        _Group2.default,
        {
          className: 'Axis',
          style: {
            pointerEvents: 'none',
            transition: 'none',
            transform: position === positionRight ? translateX(width) : position === positionBottom ? translateY(height) : undefined
          }
        },
        _react2.default.createElement(_Path2.default, {
          className: 'domain',
          d: axisPath,
          style: _extends({
            stroke: dark ? 'rgba(255,255,255, .1)' : 'rgba(0,0,0, .1)'
          }, axisStyles.line, {
            transition: 'none'
          })
        }),
        _react2.default.createElement(
          _Group2.default,
          {
            className: 'ticks',
            innerRef: function innerRef(el) {
              _this2.el = el;
            },
            style: {
              transition: 'none'
            }
          },
          ticks.map(function (tick, i) {
            return _react2.default.createElement(
              _Group2.default,
              {
                key: tick,
                className: 'tick',
                style: {
                  transition: 'none',
                  transform: transform(scale(tick) || 0)
                }
              },
              showTicks ? _react2.default.createElement(_Line2.default, {
                x1: vertical ? 0 : tickOffset,
                x2: vertical ? directionMultiplier * tickSizeInner : tickOffset,
                y1: vertical ? tickOffset : 0,
                y2: vertical ? tickOffset : directionMultiplier * tickSizeInner,
                style: _extends({
                  stroke: dark ? 'rgba(255,255,255, .1)' : 'rgba(0,0,0, .1)',
                  strokeWidth: 1
                }, axisStyles.line, {
                  transition: 'none'
                })
              }) : null,
              showGridLine && _react2.default.createElement(_Line2.default, {
                x1: vertical ? 0 : gridOffset,
                x2: vertical ? max : gridOffset,
                y1: vertical ? gridOffset : 0,
                y2: vertical ? gridOffset : max,
                style: _extends({
                  stroke: dark ? 'rgba(255,255,255, .1)' : 'rgba(0,0,0, .1)',
                  strokeWidth: 1
                }, axisStyles.line, {
                  transition: 'none'
                })
              }),
              showTicks ? _react2.default.createElement(
                _Text2.default,
                {
                  style: _extends({
                    fill: dark ? 'white' : 'black'
                  }, axisStyles.tick, {
                    transition: 'none',
                    transform: 'translate3d(' + (vertical ? directionMultiplier * spacing : tickOffset) + 'px, ' + (vertical ? tickOffset : directionMultiplier * spacing) + 'px, 0) rotate(' + -rotation + 'deg)'
                  }),
                  dominantBaseline: rotation ? 'central' : position === positionBottom ? 'hanging' : position === positionTop ? 'alphabetic' : 'central',
                  textAnchor: rotation ? 'end' : position === positionRight ? 'start' : position === positionLeft ? 'end' : 'middle'
                },
                String(format(tick, i))
              ) : null
            );
          })
        )
      );
    }
  }]);

  return Axis;
}(_react2.default.Component);

Axis.defaultProps = {
  min: undefined,
  max: undefined,
  hardMin: undefined,
  hardMax: undefined,
  base: undefined,
  tickArguments: [],
  tickValues: null,
  tickFormat: null,
  tickSizeInner: 6,
  tickSizeOuter: 6,
  tickPadding: 3,
  maxLabelRotation: 50,
  innerPadding: 0.2,
  outerPadding: 0.1,
  showGrid: null,
  showTicks: true,
  show: true
};
exports.default = (0, _Context.ChartConnect)(function () {
  var selectors = {
    gridWidth: _Selectors2.default.gridWidth(),
    gridHeight: _Selectors2.default.gridHeight(),
    primaryAxes: _Selectors2.default.primaryAxes()
  };
  return function (state, props) {
    var type = props.type,
        position = props.position,
        userID = props.id;

    var id = userID || type + '_' + position;

    return {
      id: id,
      primaryAxes: selectors.primaryAxes(state), // This is needed in AxisLinear.updateScale.js
      width: selectors.gridWidth(state),
      height: selectors.gridHeight(state),
      materializedData: state.materializedData,
      axis: state.axes && state.axes[id],
      dark: state.dark
    };
  };
})(Axis);


function translateX(x) {
  return 'translate3d(' + x + 'px, 0, 0)';
}

function translateY(y) {
  return 'translate3d(0, ' + y + 'px, 0)';
}