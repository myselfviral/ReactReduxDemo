'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Context = require('../utils/Context');

var _Utils = require('../utils/Utils');

var _Utils2 = _interopRequireDefault(_Utils);

var _Selectors = require('../utils/Selectors');

var _Selectors2 = _interopRequireDefault(_Selectors);

var _interactionMethods = require('../utils/interactionMethods');

var _Rectangle = require('../primitives/Rectangle');

var _Rectangle2 = _interopRequireDefault(_Rectangle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//


var Bar = function (_React$PureComponent) {
  _inherits(Bar, _React$PureComponent);

  function Bar(props) {
    _classCallCheck(this, Bar);

    var _this = _possibleConstructorReturn(this, (Bar.__proto__ || Object.getPrototypeOf(Bar)).call(this, props));

    if (!props.interaction) {
      _this.props.dispatch(function (state) {
        return _extends({}, state, {
          interaction: 'element'
        });
      });
    }
    if (!props.hoverMode) {
      _this.props.dispatch(function (state) {
        return _extends({}, state, {
          hoverMode: 'primary'
        });
      });
    }
    _this.selectSeries = _interactionMethods.selectSeries.bind(_this);
    _this.hoverSeries = _interactionMethods.hoverSeries.bind(_this);
    _this.selectDatum = _interactionMethods.selectDatum.bind(_this);
    _this.hoverDatum = _interactionMethods.hoverDatum.bind(_this);
    return _this;
  }

  _createClass(Bar, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          series = _props.series,
          visibility = _props.visibility,
          primaryAxes = _props.primaryAxes,
          selected = _props.selected,
          hovered = _props.hovered,
          interaction = _props.interaction;


      var style = series.getStatusStyle(_Utils2.default.getStatus(series, hovered, selected));

      var _ref = series.primaryAxisID ? primaryAxes.find(function (d) {
        return d.id === series.primaryAxisID;
      }) : primaryAxes[0],
          barOffset = _ref.barOffset;

      var interactiveSeries = interaction === 'series';
      var seriesInteractionProps = interactiveSeries ? {
        onClick: function onClick() {
          return _this2.selectSeries(series);
        },
        onMouseEnter: function onMouseEnter() {
          return _this2.hoverSeries(series);
        },
        onMouseMove: function onMouseMove() {
          return _this2.hoverSeries(series);
        },
        onMouseLeave: function onMouseLeave() {
          return _this2.hoverSeries(null);
        }
      } : {};
      return _react2.default.createElement(
        'g',
        { className: 'series bar' },
        series.datums.map(function (datum, i) {
          var x = datum ? datum.x : 0;
          var y = datum ? datum.y : 0;
          var base = datum ? datum.base : 0;
          var size = datum ? datum.size : 0;
          var x1 = void 0;
          var y1 = void 0;
          var x2 = void 0;
          var y2 = void 0;
          if (primaryAxes.find(function (d) {
            return d.vertical;
          })) {
            x1 = base;
            x2 = x;
            y1 = y + barOffset;
            y2 = y1 + size;
          } else {
            x1 = x + barOffset;
            x2 = x1 + size;
            y1 = y;
            y2 = base;
          }

          var dataStyle = datum.getStatusStyle(_Utils2.default.getStatus(datum, hovered, selected));

          var interactiveDatum = interaction === 'element';
          var datumInteractionProps = interactiveDatum ? {
            onClick: function onClick() {
              return _this2.selectDatum(datum);
            },
            onMouseEnter: function onMouseEnter() {
              return _this2.hoverDatum(datum);
            },
            onMouseMove: function onMouseMove() {
              return _this2.hoverDatum(datum);
            },
            onMouseLeave: function onMouseLeave() {
              return _this2.hoverDatum(null);
            }
          } : {};

          return _react2.default.createElement(_Rectangle2.default, _extends({
            style: _extends({}, style, style.rectangle, dataStyle, dataStyle.rectangle, {
              pointerEvents: interactiveSeries || interactiveDatum ? 'all' : 'none'
            }),
            key: i,
            x1: Number.isNaN(x1) ? null : x1,
            y1: Number.isNaN(y1) ? null : y1,
            x2: Number.isNaN(x2) ? null : x2,
            y2: Number.isNaN(y2) ? null : y2,
            opacity: visibility
          }, seriesInteractionProps, datumInteractionProps));
        })
      );
    }
  }]);

  return Bar;
}(_react2.default.PureComponent);

Bar.isBar = true;

Bar.plotDatum = function (datum, _ref2) {
  var xAxis = _ref2.xAxis,
      yAxis = _ref2.yAxis,
      primaryAxis = _ref2.primaryAxis,
      secondaryAxis = _ref2.secondaryAxis;

  datum.x = xAxis.scale(datum.xValue);
  datum.y = yAxis.scale(datum.yValue);
  datum.defined = _Utils2.default.isValidPoint(datum.xValue) && _Utils2.default.isValidPoint(datum.yValue);
  datum.base = secondaryAxis.scale(datum.baseValue);
  datum.size = primaryAxis.barSize;

  if (!secondaryAxis.stacked) {
    datum.size = primaryAxis.seriesBarSize;
    // Use the seriesTypeIndex here in case we have mixed types.
    var seriesBandScaleOffset = primaryAxis.seriesBandScale(datum.seriesTypeIndex);
    if (secondaryAxis.vertical) {
      datum.x += seriesBandScaleOffset;
    } else {
      datum.y += seriesBandScaleOffset;
    }
  }

  // Set the default focus point
  datum.focus = {
    x: datum.x,
    y: datum.y,
    horizontalPadding: secondaryAxis.vertical ? datum.size / 2 : 0,
    verticalPadding: secondaryAxis.vertical ? 0 : datum.size / 2

    // Adjust the focus point for bars
  };if (!primaryAxis.vertical) {
    datum.focus.x += primaryAxis.type !== 'ordinal' ? 0 : datum.size / 2;
  } else {
    datum.focus.y += primaryAxis.type !== 'ordinal' ? 0 : datum.size / 2;
  }

  // Set the pointer points (used in voronoi)
  datum.pointerPoints = [
  // End of bar
  datum.focus,
  // Start of bar
  {
    x: primaryAxis.vertical ? primaryAxis.position === 'left' ? datum.base - 1 : datum.base : datum.focus.x,
    y: !primaryAxis.vertical ? primaryAxis.position === 'bottom' ? datum.base - 1 : datum.base : datum.focus.y
  }];
};

Bar.buildStyles = function (series, _ref3) {
  var getStyles = _ref3.getStyles,
      getDatumStyles = _ref3.getDatumStyles,
      defaultColors = _ref3.defaultColors;

  var defaults = {
    // Pass some sane defaults
    color: defaultColors[series.index % (defaultColors.length - 1)]
  };

  series.getStatusStyle = function (status) {
    series.style = _Utils2.default.getStatusStyle(series, status, getStyles, defaults);
    return series.style;
  };

  // We also need to decorate each datum in the same fashion
  series.datums.forEach(function (datum) {
    datum.getStatusStyle = function (status) {
      datum.style = _Utils2.default.getStatusStyle(datum, status, getDatumStyles, defaults);
      return datum.style;
    };
  });
};

exports.default = (0, _Context.ChartConnect)(function () {
  var selectors = {
    primaryAxes: _Selectors2.default.primaryAxes()
  };
  return function (state) {
    return {
      primaryAxes: selectors.primaryAxes(state),
      hovered: state.hovered,
      selected: state.selected,
      interaction: state.interaction
    };
  };
})(Bar);