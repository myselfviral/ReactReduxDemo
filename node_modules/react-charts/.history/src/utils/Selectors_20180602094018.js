import Memoize from './Memoize'

export default {
  primaryAxes: () =>
    Memoize(
      state => [state.axes],
      axes => {
        if (!axes) return []
        return Object.keys(axes)
          .map(key => {
            if (axes[key].primary) {
              return axes[key]
            }
            return null
          })
          .filter(Boolean)
      }
    ),

  secondaryAxes: () =>
    Memoize(
      state => [state.axes],
      axes => {
        if (!axes) return []
        return Object.keys(axes)
          .map(key => {
            if (!axes[key].primary) {
              return axes[key]
            }
            return null
          })
          .filter(Boolean)
      }
    ),

  offset: () =>
    Memoize(
      state => [
        (state && state.offset && state.offset.left) || 0,
        (state && state.offset && state.offset.top) || 0,
      ],
      (left, top) => ({
        left,
        top,
      })
    ),

  gridX: () =>
    Memoize(
      state => [
        (state && state.padding && state.padding.left) || 0,
        state && state.axesDimensions && state.axesDimensions.left,
        state && state.axesDimensions && state.axesDimensions.top,
        state && state.axesDimensions && state.axesDimensions.bottom,
      ],
      (paddingLeft, axesDimensionsLeft, axesDimensionsTop, axesDimensionsBottom) => {
        const axesLeftWidth = (axesDimensionsLeft && sumObjBy(axesDimensionsLeft, 'width')) || 0
        const axesTopLeft = (axesDimensionsTop && sumObjBy(axesDimensionsTop, 'left')) || 0
        const axesBottomLeft = (axesDimensionsBottom && sumObjBy(axesDimensionsBottom, 'left')) || 0
        return paddingLeft + Math.max(axesLeftWidth, axesTopLeft, axesBottomLeft)
      }
    ),

  gridY: () =>
    Memoize(
      state => [
        (state && state.padding && state.padding.top) || 0,
        state && state.axesDimensions && state.axesDimensions.top,
        state && state.axesDimensions && state.axesDimensions.left,
        state && state.axesDimensions && state.axesDimensions.right,
      ],
      (paddingTop, axesDimensionsTop, axesDimensionsLeft, axesDimensionsRight) => {
        const axesTopHeight = (axesDimensionsTop && sumObjBy(axesDimensionsTop, 'height')) || 0
        const axesLeftTop = (axesDimensionsLeft && sumObjBy(axesDimensionsLeft, 'top')) || 0
        const axesRightTop = (axesDimensionsRight && sumObjBy(axesDimensionsRight, 'top')) || 0
        return paddingTop + Math.max(axesTopHeight, axesLeftTop, axesRightTop)
      }
    ),

  gridWidth: () =>
    Memoize(
      state => [
        state && state.width,
        state && state.padding,
        state && state.axesDimensions && state.axesDimensions.top,
        state && state.axesDimensions && state.axesDimensions.bottom,
        state && state.axesDimensions && state.axesDimensions.left,
        state && state.axesDimensions && state.axesDimensions.right,
      ],
      (
        width,
        padding,
        axesDimensionsTop,
        axesDimensionsBottom,
        axesDimensionsLeft,
        axesDimensionsRight
      ) => {
        const paddingLeft = (padding && padding.left) || 0
        const paddingRight = (padding && padding.right) || 0
        const axesLeftWidth = (axesDimensionsLeft && sumObjBy(axesDimensionsLeft, 'width')) || 0
        const axesRightWidth = (axesDimensionsRight && sumObjBy(axesDimensionsRight, 'width')) || 0
        const axesTopLeft = (axesDimensionsTop && sumObjBy(axesDimensionsTop, 'left')) || 0
        const axesTopRight = (axesDimensionsTop && sumObjBy(axesDimensionsTop, 'right')) || 0
        const axesBottomLeft = (axesDimensionsBottom && sumObjBy(axesDimensionsBottom, 'left')) || 0
        const axesBottomRight =
          (axesDimensionsBottom && sumObjBy(axesDimensionsBottom, 'right')) || 0

        return (
          (width || 0) -
          paddingLeft -
          paddingRight -
          Math.max(axesLeftWidth, axesTopLeft, axesBottomLeft) -
          Math.max(axesRightWidth, axesTopRight, axesBottomRight)
        )
      }
    ),

  gridHeight: () =>
    Memoize(
      state => [
        state && state.height,
        state && state.padding,
        state && state.axesDimensions && state.axesDimensions.top,
        state && state.axesDimensions && state.axesDimensions.bottom,
        state && state.axesDimensions && state.axesDimensions.left,
        state && state.axesDimensions && state.axesDimensions.right,
      ],
      (
        height,
        padding,
        axesDimensionsTop,
        axesDimensionsBottom,
        axesDimensionsLeft,
        axesDimensionsRight
      ) => {
        const paddingTop = (padding && padding.top) || 0
        const paddingBottom = (padding && padding.right) || 0
        const axesTopHeight = (axesDimensionsTop && sumObjBy(axesDimensionsTop, 'height')) || 0
        const axesBottomHeight =
          (axesDimensionsBottom && sumObjBy(axesDimensionsBottom, 'height')) || 0
        const axesLeftTop = (axesDimensionsLeft && sumObjBy(axesDimensionsLeft, 'top')) || 0
        const axesLeftBottom = (axesDimensionsLeft && sumObjBy(axesDimensionsLeft, 'bottom')) || 0
        const axesRightTop = (axesDimensionsRight && sumObjBy(axesDimensionsRight, 'top')) || 0
        const axesRightBottom =
          (axesDimensionsRight && sumObjBy(axesDimensionsRight, 'bottom')) || 0

        return (
          (height || 0) -
          paddingTop -
          paddingBottom -
          Math.max(axesTopHeight, axesLeftTop, axesRightTop) -
          Math.max(axesBottomHeight, axesLeftBottom, axesRightBottom)
        )
      }
    ),
}

function sumObjBy (obj, str) {
  return Object.keys(obj)
    .map(key => obj[key])
    .reduce((prev, curr) => prev + curr[str] || 0, 0)
}
