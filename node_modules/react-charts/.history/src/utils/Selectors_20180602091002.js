import Memoize from './Memoize'

export default {
  primaryAxes: () =>
    Memoize(
      state => [state.axes],
      axes => {
        if (!axes) return []
        return Object.keys(axes)
          .map(key => {
            if (axes[key].primary) {
              return axes[key]
            }
            return null
          })
          .filter(Boolean)
      }
    ),

  secondaryAxes: () =>
    Memoize(
      state => [state.axes],
      axes => {
        if (!axes) return []
        return Object.keys(axes)
          .map(key => {
            if (!axes[key].primary) {
              return axes[key]
            }
            return null
          })
          .filter(Boolean)
      }
    ),

  offset: () =>
    Memoize(
      state => [
        (state && state.offset && state.offset.left) || 0,
        (state && state.offset && state.offset.top) || 0,
      ],
      (left, top) => ({
        left,
        top,
      })
    ),

  gridX: () =>
    Memoize(
      state => [
        (state && state.padding && state.padding.left) || 0,
        (state &&
          state.axisDimensions &&
          state.axisDimensions.left &&
          sumObjBy(state.axisDimensions.left, 'width')) ||
          0,
        (state &&
          state.axisDimensions &&
          state.axisDimensions.top &&
          sumObjBy(state.axisDimensions.top, 'left')) ||
          0,
        (state &&
          state.axisDimensions &&
          state.axisDimensions.bottom &&
          sumObjBy(state.axisDimensions.bottom, 'left')) ||
          0,
      ],
      (paddingLeft, axesLeftWidth, axesTopLeft, axesBottomLeft) =>
        paddingLeft + Math.max(axesLeftWidth, axesTopLeft, axesBottomLeft)
    ),

  gridY: () =>
    Memoize(
      state => [
        (state && state.padding && state.padding.top) || 0,
        (state &&
          state.axisDimensions &&
          state.axisDimensions.top &&
          sumObjBy(state.axisDimensions.top, 'height')) ||
          0,
        (state &&
          state.axisDimensions &&
          state.axisDimensions.left &&
          sumObjBy(state.axisDimensions.left, 'top')) ||
          0,
        (state &&
          state.axisDimensions &&
          state.axisDimensions.right &&
          sumObjBy(state.axisDimensions.right, 'top')) ||
          0,
      ],
      (paddingTop, axesTopHeight, axesLeftTop, axesRightTop) =>
        paddingTop + Math.max(axesTopHeight, axesLeftTop, axesRightTop)
    ),

  gridWidth: () =>
    Memoize(
      state => [state && state.width, state && state.padding, state && state.axisDimensions],
      (width, padding, axisDimensions) => {
        const paddingLeft = padding && padding.left
        const paddingRight = padding && padding.right
        const axesLeftWidth =
          (axisDimensions && axisDimensions.left && sumObjBy(axisDimensions.left, 'width')) || 0
        const axesRightWidth =
          (axisDimensions && axisDimensions.right && sumObjBy(axisDimensions.right, 'width')) || 0
        const axesTopLeft =
          (axisDimensions && axisDimensions.top && sumObjBy(axisDimensions.top, 'left')) || 0
        const axesTopRight =
          (axisDimensions && axisDimensions.top && sumObjBy(axisDimensions.top, 'right')) || 0
        const axesBottomLeft =
          (axisDimensions && axisDimensions.bottom && sumObjBy(axisDimensions.bottom, 'left')) || 0
        const axesBottomRight =
          (axisDimensions && axisDimensions.bottom && sumObjBy(axisDimensions.bottom, 'right')) || 0

        return (
          (width || 0) -
          (paddingLeft || 0) -
          (paddingRight || 0) -
          Math.max(axesLeftWidth, axesTopLeft, axesBottomLeft) -
          Math.max(axesRightWidth, axesTopRight, axesBottomRight)
        )
      }
    ),

  gridHeight: () =>
    Memoize(
      state => [state && state.width, state && state.padding, state && state.axisDimensions],
      (width, padding, axisDimensions) => {
        const paddingLeft = padding && padding.left
        const paddingRight = padding && padding.right
        const axesLeftWidth =
          (axisDimensions && axisDimensions.left && sumObjBy(axisDimensions.left, 'width')) || 0
        const axesRightWidth =
          (axisDimensions && axisDimensions.right && sumObjBy(axisDimensions.right, 'width')) || 0
        const axesTopLeft =
          (axisDimensions && axisDimensions.top && sumObjBy(axisDimensions.top, 'left')) || 0
        const axesTopRight =
          (axisDimensions && axisDimensions.top && sumObjBy(axisDimensions.top, 'right')) || 0
        const axesBottomLeft =
          (axisDimensions && axisDimensions.bottom && sumObjBy(axisDimensions.bottom, 'left')) || 0
        const axesBottomRight =
          (axisDimensions && axisDimensions.bottom && sumObjBy(axisDimensions.bottom, 'right')) || 0

        return (
          (width || 0) -
          (paddingLeft || 0) -
          (paddingRight || 0) -
          Math.max(axesLeftWidth, axesTopLeft, axesBottomLeft) -
          Math.max(axesRightWidth, axesTopRight, axesBottomRight)
        )
      }
    ),
}

function sumObjBy (obj, str) {
  return Object.keys(obj)
    .map(key => obj[key])
    .reduce((prev, curr) => prev + curr[str] || 0, 0)
}
