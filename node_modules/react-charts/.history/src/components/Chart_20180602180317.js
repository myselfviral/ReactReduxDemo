import React, { Component } from 'react'
import RAF from 'raf'
//
import Selectors from '../utils/Selectors'
import HyperResponsive from '../utils/HyperResponsive'
import Utils from '../utils/Utils'
import * as Debug from '../utils/Debug'
import { ChartProvider, PointerProvider } from '../utils/Context'

import Rectangle from '../primitives/Rectangle'
import Voronoi from '../components/Voronoi'

const debug = process.env.NODE_ENV === 'development'

const getDefaultChartState = () => ({
  hovered: {
    active: false,
    series: null,
    datums: [],
  },
  cursors: {},
  axes: {},
  tooltip: {},
  axisDimensions: {},
})

const getDefaultPointerState = () => ({
  pointer: {},
})

class Chart extends Component {
  static defaultProps = {
    getSeries: d => d,
    getDatums: d => (Utils.isArray(d) ? d : d.datums || d.data),
    getLabel: (d, i) => d.label || `Series ${i + 1}`,
    getSeriesID: (d, i) => i,
    getPrimary: d => (Utils.isArray(d) ? d[0] : d.primary || d.x),
    getSecondary: d => (Utils.isArray(d) ? d[1] : d.secondary || d.y),
    getR: d => (Utils.isArray(d) ? d[2] : d.radius || d.r),
    getPrimaryAxisID: s => s.primaryAxisID,
    getSecondaryAxisID: s => s.secondaryAxisID,
    onHover: () => {},
    interaction: null,
    hoverMode: 'primary',
    groupMode: 'primary',
    showVoronoi: false,
  }
  constructor () {
    super()
    this.state = {
      chartState: {
        ...getDefaultChartState(),
      },
      pointerState: {
        // eslint-disable-next-line
        dispatch: fn =>
          this.setState(state => ({
            pointerState: fn(state),
          })),
      },
    }
    this.pointerState = {
      ...getDefaultPointerState(),
      dispatch: fn => {
        this.pointerState = fn(this.pointerState)
        this.setState({})
      },
    }
    this.selectors = {
      gridX: Selectors.gridX(),
      gridY: Selectors.gridY(),
      offset: Selectors.offset(),
    }
  }
  static getDerivedStateFromProps (props, state) {
    const {
      data, width, height, interaction, hoverMode, groupMode, showVoronoi,
    } = props
    if (
      Utils.shallowCompare(props, state, [
        'data',
        'width',
        'height',
        'interaction',
        'hoverMode',
        'groupMode',
        'showVoronoi',
      ])
    ) {
      return {
        data,
        width,
        height,
        interaction,
        hoverMode,
        groupMode,
        showVoronoi,
      }
    }
    return null
  }
  componentDidUpdate (prevProps, prevState) {
    if (Utils.shallowCompare(prevProps, this.props, ['data', 'width', 'height'])) {
      this.updateDataModel(this.props)
    } else {
      RAF(() => this.measure(prevProps, prevState))
    }
  }
  updateDataModel = props => {
    const { data, width, height } = props
    let {
      getSeries,
      getDatums,
      getLabel,
      getSeriesID,
      getPrimary,
      getSecondary,
      getR,
      getPrimaryAxisID,
      getSecondaryAxisID,
    } = props

    // Normalize getters
    getSeries = Utils.normalizePathGetter(getSeries)
    getDatums = Utils.normalizePathGetter(getDatums)
    getLabel = Utils.normalizePathGetter(getLabel)
    getSeriesID = Utils.normalizePathGetter(getSeriesID)
    getPrimary = Utils.normalizePathGetter(getPrimary)
    getSecondary = Utils.normalizePathGetter(getSecondary)
    getR = Utils.normalizePathGetter(getR)
    getPrimaryAxisID = Utils.normalizePathGetter(getPrimaryAxisID)
    getSecondaryAxisID = Utils.normalizePathGetter(getSecondaryAxisID)

    // Check for data
    if (!data) {
      if (debug) Debug.noData(this)
      return
    }

    // getSeries
    const series = getSeries(data)

    // Check for data
    if (!series) {
      if (debug) Debug.noData(this)
      return
    }

    // First access the data, and provide it to the context
    const preMaterializedData = series.map((s, seriesIndex) => {
      const seriesID = getSeriesID(s, seriesIndex, data)
      const seriesLabel = getLabel(s, seriesIndex, data)
      const primaryAxisID = getPrimaryAxisID(s, seriesIndex, data)
      const secondaryAxisID = getSecondaryAxisID(s, seriesIndex, data)
      const series = {
        original: s,
        index: seriesIndex,
        id: seriesID,
        label: seriesLabel,
        primaryAxisID,
        secondaryAxisID,
        datums: getDatums(s, seriesIndex, data).map((d, index) => ({
          originalSeries: s,
          seriesIndex,
          seriesID,
          seriesLabel,
          index,
          original: d,
          primary: getPrimary(d, index, s, seriesIndex, data),
          secondary: getSecondary(d, index, s, seriesIndex, data),
          r: getR(d, index, s, seriesIndex, data),
        })),
      }
      return series
    })

    // Provide the preMaterializedData to the chart instance
    this.state.dispatch(state => ({
      ...state,
      preMaterializedData,
      width,
      height,
    }))
  }
  measure = (prevProps, prevState) => {
    if (!this.el) {
      return
    }
    this.dims = this.el.getBoundingClientRect()
    const { offset } = this.getSelectedState(this.state)
    const { offset: prevOffset } = this.getSelectedState(prevState)

    if (prevProps && (offset.left !== prevOffset.left || offset.top !== prevOffset.top)) {
      this.props.dispatch(state => ({
        ...state,
        offset: {
          left: this.el.offsetLeft,
          top: this.el.offsetTop,
        },
      }))
    }
  }
  getSelectedState (state) {
    return {
      gridX: this.selectors.gridX(state),
      gridY: this.selectors.gridY(state),
      offset: this.selectors.offset(state),
    }
  }
  render () {
    const {
      style, width, height, handleRef, children,
    } = this.props

    const { gridX, gridY } = this.getSelectedState(this.state)

    const allChildren = React.Children.toArray(children)
    const svgChildren = allChildren.filter(d => !d.type.isHtml)
    const htmlChildren = allChildren.filter(d => d.type.isHtml)

    return (
      <ChartProvider value={this.state}>
        <PointerProvider value={this.pointerState}>
          <div
            ref={handleRef}
            className="ReactChart"
            style={{
              width,
              height,
              position: 'relative',
            }}
          >
            <svg
              ref={el => {
                this.el = el
              }}
              style={{
                width,
                height,
                overflow: 'hidden',
                ...style,
              }}
            >
              <g
                onMouseEnter={e => {
                  e.persist()
                  this.onMouseMove(e)
                }}
                onMouseMove={e => {
                  e.persist()
                  this.onMouseMove(e)
                }}
                onMouseLeave={this.onMouseLeave}
                onMouseDown={this.onMouseDown}
                style={{
                  transform: `translate3d(${gridX || 0}px, ${gridY || 0}px, 0)`,
                }}
              >
                <Rectangle
                  // This is to ensure the pointer always has something to hit
                  x1={-gridX}
                  x2={width - gridX}
                  y1={-gridY}
                  y2={height - gridY}
                  style={{
                    opacity: 0,
                  }}
                />
                <Voronoi />
                {svgChildren}
              </g>
            </svg>
            {htmlChildren}
          </div>
        </PointerProvider>
      </ChartProvider>
    )
  }
  onMouseMove = Utils.throttle(e => {
    const { clientX, clientY } = e
    const { gridX, gridY } = this.props
    const { dispatch } = this.pointerState

    dispatch(state => {
      const x = clientX - this.dims.left - gridX
      const y = clientY - this.dims.top - gridY

      const pointer = {
        ...state.pointer,
        active: true,
        x,
        y,
        dragging: state.pointer && state.pointer.down,
      }
      return {
        ...state,
        pointer,
      }
    })
  })
  onMouseLeave = () => {
    const { dispatch } = this.pointerState
    dispatch(state => ({
      ...state,
      pointer: {
        ...state.pointer,
        active: false,
      },
      hovered: {
        ...state.hovered,
        active: false,
      },
    }))
  }
  onMouseDown = () => {
    const { dispatch } = this.pointerState

    document.addEventListener('mouseup', this.onMouseUp)
    document.addEventListener('mousemove', this.onMouseMove)

    dispatch(state => ({
      ...state,
      pointer: {
        ...state.pointer,
        sourceX: state.pointer.x,
        sourceY: state.pointer.y,
        down: true,
      },
    }))
  }
  onMouseUp = () => {
    const { dispatch } = this.pointerState

    document.removeEventListener('mouseup', this.onMouseUp)
    document.removeEventListener('mousemove', this.onMouseMove)

    dispatch(state => ({
      ...state,
      pointer: {
        ...state.pointer,
        down: false,
        dragging: false,
        released: {
          x: state.pointer.x,
          y: state.pointer.y,
        },
      },
    }))
  }
}

export default props => (
  <HyperResponsive
    render={({ handleRef, width, height }) => (
      <Chart {...props} width={width} height={height} handleRef={handleRef} />
    )}
  />
)
